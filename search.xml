<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hytrix线程池设置坑</title>
    <url>/2020/07/14/Hytrix%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%AE%BE%E7%BD%AE%E5%9D%91/</url>
    <content><![CDATA[<p>最近遇到修改 Hytrix 线程池配置，不生效的情况。然后发现了一些坑。。。</p>
<a id="more"></a>

<h3 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h3><p>基于hystrix版本</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.netflix.hystrix<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hystrix-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">hystrix.threadpool.default.coreSize</span>=<span class="string">10</span></span><br><span class="line"><span class="meta">hystrix.threadpool.default.maximumSize</span>=<span class="string">15</span></span><br><span class="line"><span class="meta">hystrix.threadpool.default.allowMaximumSizeToDivergeFromCoreSize</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">hystrix.threadpool.default.maxQueueSize</span>=<span class="string">1000</span></span><br><span class="line"><span class="meta">hystrix.threadpool.default.queueSizeRejectionThreshold</span>=<span class="string">1000</span></span><br></pre></td></tr></table></figure>

<p>现象</p>
<p>在此配置之下，测试线程数始终不能达到最大线程数</p>
<h3 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h3><p>是什么样的逻辑，导致<code>maximumSize</code>配置失效？需要一步步深入源码探索</p>
<ul>
<li><p>hytrixs使用的线程池是jdk的线程池吗？</p>
<p><code>HystrixThreadPoolProperties</code> ：hytrix线程池的配置类</p>
<p><code>HystrixThreadPool</code> ：hytrix的线程池interface，其中有静态内部类<code>Factory</code>,一眼看到<code>getInstance</code>方法，追溯到另一个静态内部类<code>HystrixThreadPoolDefault</code>，再到<code>HystrixConcurrencyStrategy</code>,终于找到了线程池的创建方法<code>getThreadPool</code></p>
<p><img src="http://qiniu.5ires.top/uPic/image-20200714190115273.png" alt="image-20200714190115273"></p>
<p>由此可以看出hytrix是使用jdk的线程池，所以线程池的运行规则应该都是一样的。</p>
<blockquote>
<p>回顾java线程池的运行规则：</p>
<ul>
<li>假设第一次运行线程池，当有任务来的时候，首先创建线程直到线程数达到核心线程数</li>
<li>核心线程数量的线程被占满，之后的任务加入到阻塞队列当中</li>
<li>当核心线程数和阻塞队列都被占满，之后的任务到达线程池，线程池则会创建更多的线程，直到存在的线程数量达到最大线程配置的数量</li>
<li>当最大线程数量的线程和队列都被占满，之后的任务到达线程池，那么线程池会根据拒绝策略执行相关逻辑</li>
</ul>
</blockquote>
</li>
</ul>
<ul>
<li><p>导致的失效的具体代码逻辑</p>
<p><code>HystrixContextScheduler</code>,由于hytrix的源代码是使用<code>RxJava</code>框架来写的，不太理解，最终打断点找到了此类，进入了<code>schedule</code>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Subscription <span class="title">schedule</span><span class="params">(Action0 action)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (threadPool != <span class="keyword">null</span>) &#123;</span><br><span class="line">  		<span class="comment">// 线程池队列无可用空间时，直接拒绝任务  </span></span><br><span class="line">      <span class="keyword">if</span> (!threadPool.isQueueSpaceAvailable()) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">&quot;Rejected command because thread-pool queueSize is at rejection threshold.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">return</span> worker.schedule(<span class="keyword">new</span> HystrixContexSchedulerAction(concurrencyStrategy, action));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，再添加action之前，会校验线程池的队列空间是否可用。具体逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isQueueSpaceAvailable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 1. 配置的队列的数量小于等于0，直接返回true。那么继上一步任务会给到线程池，由它决定任务执行与否</span></span><br><span class="line">   <span class="keyword">if</span> (queueSize &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">// 2. 线程池中已有任务队列的数量 vs queueSizeRejectionThreshold配置数量</span></span><br><span class="line">     <span class="keyword">return</span> threadPool.getQueue().size() &lt; properties.queueSizeRejectionThreshold().get();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据此代码逻辑可以得出：</p>
<ul>
<li>配置线程池队列大小参数为-1时，任务的执行与否交给java线程池决定，此时队列是同步队列，那么当并发任务数量大于核心线程数小于最大线程数的时候，是应该会创建新的线程来执行此任务。那么<code>maximumSize</code>的配置是有效的</li>
<li>配置线程池队列的<code>maxQueueSize</code>大于等于<code>queueSizeRejectionThreshold</code>配置时。若此时并发数达到了核心线程数和<code>maxQueueSize</code>配置之和，再有任务需要执行时，根据此逻辑，会返回<code>false</code>，拒绝任务的执行，并不会交给线程池处理。从而使得<code>maximumSize</code>的配置是无效的。</li>
</ul>
<p>由此，我们追溯到了<code>maximumSize</code>配置无效的原因。</p>
</li>
</ul>
<h3 id="让maximumSize变得有效"><a href="#让maximumSize变得有效" class="headerlink" title="让maximumSize变得有效"></a>让<code>maximumSize</code>变得有效</h3><ul>
<li>不使用线程池的队列，直接将maxQueueSize配置设为 -1</li>
<li><code>queueSizeRejectionThreshold</code>配置大于<code>maxQueueSize</code>也可以让线程池中线程的数量达到<code>maximumSize</code>数量，但是此时<code>queueSizeRejectionThreshold</code>配置并没有起到它应该承担的意义，因为线程池中队列的大小永远不可能达到<code>queueSizeRejectionThreshold</code>配置的数量</li>
</ul>
<h3 id="验证分析"><a href="#验证分析" class="headerlink" title="验证分析"></a>验证分析</h3><ul>
<li><p><a href="https://github.com/Netflix/Hystrix/wiki/Configuration#ThreadPool">hytrix线程池配置简介</a></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 核心线程数 默认值10</span></span><br><span class="line"><span class="meta">hystrix.threadpool.default.coreSize</span>=<span class="string">10</span></span><br><span class="line"><span class="comment"># 最大线程数 默认值10 在1.5.9版本之前该值总是等于coreSize</span></span><br><span class="line"><span class="meta">hystrix.threadpool.default.maximumSize</span>=<span class="string">10</span></span><br><span class="line"><span class="comment"># 阻塞队列大小 默认值-1表示使用同步队列 </span></span><br><span class="line"><span class="meta">hystrix.threadpool.default.maxQueueSize</span>=<span class="string">-1</span></span><br><span class="line"><span class="comment"># 阻塞队列大小拒绝阈值 默认值为5 当maxQueueSize=-1时，不起作用</span></span><br><span class="line"><span class="meta">hystrix.threadpool.default.queueSizeRejectionThreshold</span>=<span class="string">5</span></span><br><span class="line"><span class="comment"># 释放线程时间 min为单位 默认为1min，当最大线程数大于核心线程数的时</span></span><br><span class="line"><span class="meta">hystrix.threadpool.default.keepAliveTimeMinutes</span>=<span class="string">1</span></span><br><span class="line"><span class="comment"># 是否允许maximumSize配置生效，默认值为false</span></span><br><span class="line"><span class="meta">hystrix.threadpool.default.allowMaximumSizeToDivergeFromCoreSize</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>代码验证</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixThreadPoolTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">      	<span class="comment">// 变量</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> coreSize = <span class="number">5</span>, maximumSize = <span class="number">10</span>, maxQueueSize = <span class="number">5</span>, rejThresholdSize = <span class="number">6</span>;</span><br><span class="line">        HystrixCommand.Setter commandConfig = generateCommandConfig(coreSize, maximumSize, maxQueueSize, rejThresholdSize);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Run command once, so we can get metrics.</span></span><br><span class="line">        runOnce(commandConfig);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟并发</span></span><br><span class="line">        <span class="keyword">final</span> CountDownLatch stopLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        List&lt;Thread&gt; threads = <span class="keyword">new</span> ArrayList&lt;Thread&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; coreSize + maximumSize + maxQueueSize + rejThresholdSize; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> fi = i + <span class="number">1</span>;</span><br><span class="line">            String threadName = <span class="string">&quot;TestThread-&quot;</span> + fi;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    HystrixCommand&lt;Void&gt; command = <span class="keyword">new</span> HystrixCommand&lt;Void&gt;(commandConfig) &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> Void <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            stopLatch.await();</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    command.execute();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Thread:&quot;</span> + threadName + <span class="string">&quot; got rejected.&quot;</span>);</span><br><span class="line">                    System.out.println();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.setName(threadName);</span><br><span class="line">            threads.add(thread);</span><br><span class="line">            thread.start();</span><br><span class="line">            Thread.sleep(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;start:&quot;</span> + threadName);</span><br><span class="line">            printThreadPoolStatus();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程执行释放</span></span><br><span class="line">        stopLatch.countDown();</span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threads) &#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printThreadPoolStatus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (HystrixThreadPoolMetrics threadPoolMetrics : HystrixThreadPoolMetrics.getInstances()) &#123;</span><br><span class="line">            String name = threadPoolMetrics.getThreadPoolKey().name();</span><br><span class="line">            Number poolSize = threadPoolMetrics.getCurrentPoolSize();</span><br><span class="line">            Number queueSize = threadPoolMetrics.getCurrentQueueSize();</span><br><span class="line">            System.out.println(<span class="string">&quot;ThreadPoolKey: &quot;</span> + name + <span class="string">&quot;, PoolSize: &quot;</span> + poolSize + <span class="string">&quot;, QueueSize: &quot;</span> + queueSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> HystrixCommand.<span class="function">Setter <span class="title">generateCommandConfig</span><span class="params">(<span class="keyword">int</span> coreSize, <span class="keyword">int</span> maximumSize, <span class="keyword">int</span> maxQueueSize, <span class="keyword">int</span> rejThresholdSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String commandName = <span class="string">&quot;TestThreadPoolCommand&quot;</span>;</span><br><span class="line">        <span class="keyword">final</span> HystrixCommand.Setter commandConfig = HystrixCommand.Setter</span><br><span class="line">            .withGroupKey(HystrixCommandGroupKey.Factory.asKey(commandName))</span><br><span class="line">            .andCommandKey(HystrixCommandKey.Factory.asKey(commandName))</span><br><span class="line">            .andCommandPropertiesDefaults(</span><br><span class="line">                HystrixCommandProperties.Setter()</span><br><span class="line">                    .withExecutionTimeoutEnabled(<span class="keyword">false</span>))</span><br><span class="line">            .andThreadPoolPropertiesDefaults(</span><br><span class="line">                HystrixThreadPoolProperties.Setter()</span><br><span class="line">                    .withCoreSize(coreSize)</span><br><span class="line">                    .withMaximumSize(maximumSize)</span><br><span class="line">                    .withAllowMaximumSizeToDivergeFromCoreSize(<span class="keyword">true</span>)</span><br><span class="line">                    .withMaxQueueSize(maxQueueSize)</span><br><span class="line">                    .withQueueSizeRejectionThreshold(rejThresholdSize));</span><br><span class="line">        <span class="keyword">return</span> commandConfig;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runOnce</span><span class="params">(HystrixCommand.Setter commandConfig)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        HystrixCommand&lt;Void&gt; command = <span class="keyword">new</span> HystrixCommand&lt;Void&gt;(commandConfig) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        command.execute();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>测试数据：<code>coreSize</code>=5, <code>maxQueueSize</code>=-1，<code>maximumSize</code>=10，<code>queueSizeRejectionThreshold </code>=100</p>
<p><img src="http://qiniu.5ires.top/uPic/image-20200715145014418.png" alt="image-20200715145014418"></p>
<p>结果显示：</p>
<p>第11个任务并发的时候，hytrix拒绝执行任务，因此，<code>maxQueueSize</code>为-1，<code>maximumSize</code> - 生效，<code>queueSizeRejectionThreshold </code>- 不生效</p>
</li>
<li><p>测试数据 <code>coreSize</code>=5, <code>maxQueueSize</code>=5，<code>maximumSize</code>=10，<code>queueSizeRejectionThreshold </code>=5</p>
<p><img src="http://qiniu.5ires.top/uPic/image-20200715152012583.png" alt="image-20200715152012583"></p>
<p>结果显示：在第11个任务并发的时候，hytrix会拒绝执行任务，因此<code>maxQueueSize</code> &gt;  0并且<code>maxQueueSize</code>=<code>queueSizeRejectionThreshold </code>时，</p>
<p><code>maximumSize</code> - 不生效，<code>queueSizeRejectionThreshold </code> - 生效</p>
</li>
<li><p>测试数据 <code>coreSize</code>=5, <code>maxQueueSize</code>=5，<code>maximumSize</code>=10，<code>queueSizeRejectionThreshold </code>=3</p>
<p><img src="http://qiniu.5ires.top/uPic/image-20200715152153437.png" alt="image-20200715152153437"></p>
<p>结果显示：在第9个任务并发的时候，hytrix会拒绝任务，因此，<code>maxQueueSize</code> &gt;  0并且<code>maxQueueSize</code>&gt;<code>queueSizeRejectionThreshold </code>时，</p>
<p><code>maximumSize</code> - 不生效，<code>queueSizeRejectionThreshold </code> - 生效</p>
</li>
<li><p>测试数据 <code>coreSize</code>=5, <code>maxQueueSize</code>=5，<code>maximumSize</code>=10，<code>queueSizeRejectionThreshold </code>=20</p>
<p><img src="http://qiniu.5ires.top/uPic/image-20200715170229628.png" alt="image-20200715170229628"></p>
<p>结果显示：在第16个任务并发的时候，hytrix会拒绝任务，因此，<code>maxQueueSize</code> &gt;  0并且<code>maxQueueSize</code>&lt;<code>queueSizeRejectionThreshold </code>时，</p>
<p><code>maximumSize</code> - 生效，<code>queueSizeRejectionThreshold </code> - 生效（像摆设，它永远比maximumSize大）</p>
</li>
</ol>
</li>
</ul>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>理解此hytrix的线程池配置的关键点，是在于搞清楚hytrix是否把任务交给线程池的逻辑部分，即<code>HystrixThreadPool</code>类中的<code>isQueueSpaceAvailable</code>方法，还有理清楚jdk的线程池的任务执行原理。基于提出的问题，做以下总结：</p>
<p><code>maximumSize</code> 配置是否生效取决于 <code>maxQueueSize</code> 和 <code>queueSizeRejectionThreshold </code> 这两个配置</p>
<ul>
<li><p><code>maxQueueSize</code> = -1， hytrix使用同步队列，从而<code>queueSizeRejectionThreshold </code>也没用，<code>maximumSize</code>是生效的</p>
</li>
<li><p><code>maxQueueSize</code> &gt;=0 </p>
<ul>
<li><p><code>maxQueueSize</code> &lt; <code>queueSizeRejectionThreshold </code>, <code>maximumSize</code>生效</p>
</li>
<li><p><code>maxQueueSize</code>&gt;= <code>queueSizeRejectionThreshold </code>，<code>maximumSize</code>失效</p>
</li>
</ul>
</li>
</ul>
<p><em>Ref.</em></p>
<ol>
<li><em><a href="https://zhaox.github.io/java/2019/08/06/hystrix-thread-pool">危险的线程池</a></em></li>
<li><em><a href="https://github.com/Netflix/Hystrix/wiki/Configuration#coreSize">Hytrix-Configuration</a></em></li>
<li><a href="https://github.com/Netflix/Hystrix/issues/1589">Issues</a></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>SpringBoot-Oauth2.0（一） —— 初识</title>
    <url>/2020/08/26/SpringBoot-Oauth2.0%EF%BC%88%E4%B8%80%EF%BC%89%20-%20%E5%88%9D%E8%AF%86/</url>
    <content><![CDATA[<p>最近在搞平台 API 的安全和认证的相关东西，接口安全和认证在生产活动中是非常重要的。目前最流行的就是 Oauth2 的认证方式。接下来就用 SpringBoot 的安全依赖简单实践一下，了解一下 Oauth2 的流程。</p>
<a id="more"></a>

<h2 id="Oauth2的简单认识"><a href="#Oauth2的简单认识" class="headerlink" title="Oauth2的简单认识"></a>Oauth2的简单认识</h2><h3 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h3><p>是一种授权机制，用来授权第三方应用，获取用户数据</p>
<h3 id="授权的四种方式"><a href="#授权的四种方式" class="headerlink" title="授权的四种方式"></a>授权的四种方式</h3><ul>
<li><p>授权码模式（authorization-code）</p>
<p>此方式安全性最高，授权码通过前端传送，令牌存储在后端。主要适用于有后端的web应用。</p>
</li>
<li><p>隐藏式（implicit）</p>
<p>此方式无授权码中间步骤，很不安全。主要适用于纯前端应用。</p>
</li>
<li><p>密码式（password）</p>
<p>此方式需要用户高度信任第三方应用，风险比较大。</p>
</li>
<li><p>客户端凭证式（client credentials）</p>
<p>这种方式适用于服务器和服务器之间的应用，是关于接口安全的认证。</p>
</li>
</ul>
<h3 id="客户端凭证认证（client-credentials）"><a href="#客户端凭证认证（client-credentials）" class="headerlink" title="客户端凭证认证（client credentials）"></a>客户端凭证认证（client credentials）</h3><p>这种方式是是我们今天主要实践的认证方式。如果有同学在平时的开放当中，经常和外部第三方对接，应该很熟悉这种认证方式。我们最常见的就是在微信开发当中，到微信公众号官方服务器认证获取 access token，之后我们请求相关微信接口，需要带上此 access token 才有权限访问。</p>
<h2 id="SpringBoot-Oatuh2-简单实践"><a href="#SpringBoot-Oatuh2-简单实践" class="headerlink" title="SpringBoot Oatuh2 简单实践"></a>SpringBoot Oatuh2 简单实践</h2><p>我们简单认识 Oauth2 之后，接下来，我们就动手快速实现一下。</p>
<h3 id="大致的思路步骤："><a href="#大致的思路步骤：" class="headerlink" title="大致的思路步骤："></a>大致的思路步骤：</h3><ol>
<li>相关依赖的引入</li>
<li>配置 <ul>
<li>认证服务信息</li>
<li>资源服务信息</li>
</ul>
</li>
<li>验证<ul>
<li>获取认证 access token</li>
<li>访问资源</li>
</ul>
</li>
</ol>
<h3 id="Pom"><a href="#Pom" class="headerlink" title="Pom"></a>Pom</h3><p>要想开启 Oauth2 认证，我们必须引入 SpringBoot 安全依赖 和 Spring 的 Oauth2 的依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.security.oauth<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-security-oauth2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>引入安全认证依赖之后，SpringBoot 会对资源服务器上所有的资源默认进行保护。</p>
<h3 id="Authorization-Service-Config-认证服务配置"><a href="#Authorization-Service-Config-认证服务配置" class="headerlink" title="Authorization Service Config - 认证服务配置"></a>Authorization Service Config - 认证服务配置</h3><p>认证服务的配置，主要包括以下3个方面：</p>
<ol>
<li><p>定义 token endpoint 的安全约束</p>
<p>主要配置：是否允许客户端以 Form 表单的形式的登录、定义密码的加密方式等</p>
</li>
<li><p>定义客户端详细的信息</p>
<p>客户端的信息包括了：客户端的信息存储方式（内存 or 数据库）以及客户端的认证需要的信息，包括 client_id、client_secret、grant_type、scope</p>
</li>
<li><p>定义授权和 token endpoint 以及令牌服务。</p>
<p>可以配置授权的 endpoint、token 的存储方式等</p>
</li>
</ol>
<p>认证服务配置如下：（本次实践，本着能省掉的就省掉的配置原则）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAuthorizationServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAuthorizationServerConfigurer</span> <span class="keyword">extends</span> <span class="title">AuthorizationServerConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置安全约束相关配置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> security 定义令牌终结点上的安全约束</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthorizationServerSecurityConfigurer security)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 支持client_id、client_secret以form表单的形式登录,参考可见：微信获取access token</span></span><br><span class="line">        security.allowFormAuthenticationForClients();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置客户端详细信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clients 定义客户端详细信息服务的配置程序。可以初始化客户端详细信息，也可以只引用现有存储。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(ClientDetailsServiceConfigurer clients)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        clients.inMemory()</span><br><span class="line">            <span class="comment">// client_id</span></span><br><span class="line">            .withClient(<span class="string">&quot;gold&quot;</span>)</span><br><span class="line">            <span class="comment">// 授权方式</span></span><br><span class="line">            .authorizedGrantTypes(<span class="string">&quot;client_credentials&quot;</span>)</span><br><span class="line">            <span class="comment">// 授权范围</span></span><br><span class="line">            .scopes(<span class="string">&quot;write&quot;</span>)</span><br><span class="line">            <span class="comment">// client_secret</span></span><br><span class="line">            .secret(<span class="string">&quot;&#123;noop&#125;123456&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> endpoints 定义授权和令牌端点以及令牌服务。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthorizationServerEndpointsConfigurer endpoints)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.configure(endpoints);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>注意密码的配置，需要配置加密方式，此实践是没有用任何加密方式的。</em></p>
<p><em>相关信息见：DelegatingPasswordEncoder or PasswordEncoderFactories</em></p>
<h3 id="Resource-Service-Config-资源服务的配置"><a href="#Resource-Service-Config-资源服务的配置" class="headerlink" title="Resource Service Config - 资源服务的配置"></a>Resource Service Config - 资源服务的配置</h3><p>资源服务的配置，主要包括以下2个方面：</p>
<ol>
<li><p>资源服务的安全配置</p>
<p>可以配置 资源 ID、stateless - 资源是否仅允许基于令牌的验证、token 的存储方式等</p>
</li>
<li><p>Http 安全配置</p>
<p>我们的被保护的 API，就是在这里配置</p>
</li>
</ol>
<p>资源相关配置：</p>
<p>API：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/res/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testOauth</span><span class="params">(<span class="meta">@PathVariable</span> String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Get the resource &quot;</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>资源服务配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableResourceServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyResourceServerConfigurer</span> <span class="keyword">extends</span> <span class="title">ResourceServerConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(ResourceServerSecurityConfigurer resources)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.configure(resources);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">            .antMatchers(<span class="string">&quot;/res/**&quot;</span>).authenticated();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="配置完成小结"><a href="#配置完成小结" class="headerlink" title="配置完成小结"></a>配置完成小结</h3><p>我们已经完成了 SpringBoot 的 Oauth2 的最基本的配置。</p>
<p>Client 的相关信息：</p>
<ul>
<li>client_id : gold</li>
<li>client_secret : 123456</li>
<li>scopes : write</li>
<li>grant_type :  client_credentials</li>
</ul>
<p>接下来，我们就来验证一下我们的配置是否生效。</p>
<p>下面的请求是在 postman 中进行的。 base_url 为设置的全局变量，实际为 <a href="http://127.0.0.1:8080/">http://127.0.0.1:8080</a></p>
<h3 id="直接请求"><a href="#直接请求" class="headerlink" title="直接请求"></a>直接请求</h3><p>当我们直接请求，应用返回未授权，无法访问：</p>
<p><img src="http://qiniu.5ires.top/uPic/image-20200828171302993.png" alt="image-20200828171302993"></p>
<h3 id="获取-access-token"><a href="#获取-access-token" class="headerlink" title="获取 access token"></a>获取 access token</h3><p>springboot oauth 默认获取 token 的 endpoint 是: /oauth/token</p>
<p><img src="http://qiniu.5ires.top/uPic/image-20200828153448422.png" alt="image-20200828153448422"></p>
<p>从请求结果可以看到，我们获取了access_token，并且刷新时间是43199秒，即12个小时。</p>
<h3 id="请求被保护的资源"><a href="#请求被保护的资源" class="headerlink" title="请求被保护的资源"></a>请求被保护的资源</h3><p><img src="http://qiniu.5ires.top/uPic/image-20200828153851996.png" alt="image-20200828153851996"></p>
<p>结果来看，我们成功用 access token 访问到了被保护的资源。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文简单介绍了 Oauth2 是什么及授权方式，想了解更多 Oauth2 知识的同学，可以到<a href="http://www.ruanyifeng.com/blog/2019/04/oauth_design.html">阮一峰老师博客</a>去学习一下。之后用 SpringBoot 简单实现了客户端凭证式的认证方式，其配置的主要关键点在于理解<strong>资源服务器配置（ResourceServerConfigurer）</strong>和<strong>认证服务器配置（AuthorizationServerConfigurer）</strong>。同学们，动起来，实现一下吧！</p>
<p><strong>个人水平有限，欢迎大家指正，一起交流哦<del>~</del></strong></p>
<p><strong>demo：<a href="https://github.com/goldpumpkin/learn-demo/tree/master/springboot-oauth">https://github.com/goldpumpkin/learn-demo/tree/master/springboot-oauth</a></strong> </p>
<p><em>Reference:</em></p>
<ol>
<li><a href="https://projects.spring.io/spring-security-oauth/docs/oauth2.html">spring-security-oauth</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html">理解OAuth 2.0</a></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>SpringBoot-Oauth2.0（二）—— client 及 token 存放到数据库</title>
    <url>/2020/08/31/SpringBoot-Oauth2.0%EF%BC%88%E4%BA%8C%EF%BC%89-%20client%20%E5%8F%8A%20token%20%E5%AD%98%E6%94%BE%E5%88%B0%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<p><a href="https://juejin.im/post/6865971696017833997">上一篇</a>我们已经用最简单的方式，搭建了一个授权方式是 client_credentials 的 Oauth2 的流程。那么现在，在此基础上，我们就再往前迈一步，我们把 client 信息和 token 存储到数据库当中，方便我们管理。并且密码需要保证安全，那么就需要加密。目标很明确，那我们开始吧！</p>
<a id="more"></a>

<h2 id="client-amp-token存储到数据库"><a href="#client-amp-token存储到数据库" class="headerlink" title="client&amp;token存储到数据库"></a>client&amp;token存储到数据库</h2><h3 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h3><ol>
<li>数据库准备：只创建我们需要用到的表</li>
<li>添加数据库相关依赖：使用 mysql 数据库</li>
<li>Oauth 存储配置的设置</li>
<li>验证</li>
</ol>
<h3 id="数据库准备"><a href="#数据库准备" class="headerlink" title="数据库准备"></a>数据库准备</h3><p>在本地数据库，创建两张表：</p>
<ul>
<li>一张表存储 client 相关信息</li>
<li>另一张表存储 token</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># client 相关信息</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> oauth_client_details</span><br><span class="line">(</span><br><span class="line">    client_id               <span class="built_in">VARCHAR</span>(<span class="number">256</span>) PRIMARY <span class="keyword">KEY</span> <span class="keyword">comment</span> <span class="string">&#x27;必填，Oauth2 client_id&#x27;</span>,</span><br><span class="line">    resource_ids            <span class="built_in">VARCHAR</span>(<span class="number">256</span>) <span class="keyword">comment</span> <span class="string">&#x27;可选，资源id集合，多个资源用英文逗号隔开&#x27;</span>,</span><br><span class="line">    client_secret           <span class="built_in">VARCHAR</span>(<span class="number">256</span>) <span class="keyword">comment</span> <span class="string">&#x27;必填，Oauth2 client_secret&#x27;</span>,</span><br><span class="line">    <span class="keyword">scope</span>                   <span class="built_in">VARCHAR</span>(<span class="number">256</span>) <span class="keyword">comment</span> <span class="string">&#x27;必填，Oauth2 权限范围，比如 read，write等可自定义&#x27;</span>,</span><br><span class="line">    authorized_grant_types  <span class="built_in">VARCHAR</span>(<span class="number">256</span>) <span class="keyword">comment</span> <span class="string">&#x27;必填，Oauth2 授权类型，支持类型：authorization_code,password,refresh_token,implicit,client_credentials，多个用英文逗号隔开&#x27;</span>,</span><br><span class="line">    web_server_redirect_uri <span class="built_in">VARCHAR</span>(<span class="number">256</span>) <span class="keyword">comment</span> <span class="string">&#x27;可选，客户端的重定向URI,当grant_type为authorization_code或implicit时,此字段是需要的&#x27;</span>,</span><br><span class="line">    authorities             <span class="built_in">VARCHAR</span>(<span class="number">256</span>) <span class="keyword">comment</span> <span class="string">&#x27;可选，指定客户端所拥有的Spring Security的权限值&#x27;</span>,</span><br><span class="line">    access_token_validity   <span class="built_in">INTEGER</span> <span class="keyword">comment</span> <span class="string">&#x27;可选，access_token的有效时间值(单位:秒)，不填写框架(类refreshTokenValiditySeconds)默认12小时&#x27;</span>,</span><br><span class="line">    refresh_token_validity  <span class="built_in">INTEGER</span> <span class="keyword">comment</span> <span class="string">&#x27;可选，refresh_token的有效时间值(单位:秒)，不填写框架(类refreshTokenValiditySeconds)默认30天&#x27;</span>,</span><br><span class="line">    additional_information  <span class="built_in">VARCHAR</span>(<span class="number">4096</span>) <span class="keyword">comment</span> <span class="string">&#x27;预留字段，格式必须是json&#x27;</span>,</span><br><span class="line">    autoapprove             <span class="built_in">VARCHAR</span>(<span class="number">256</span>) <span class="keyword">comment</span> <span class="string">&#x27;该字段适用于grant_type=&quot;authorization_code&quot;的情况下，用户是否自动approve操作&#x27;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment"># token 存储</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> oauth_access_token</span><br><span class="line">(</span><br><span class="line">    token_id          <span class="built_in">VARCHAR</span>(<span class="number">256</span>) <span class="keyword">comment</span> <span class="string">&#x27;MD5加密后存储的access_token&#x27;</span>,</span><br><span class="line">    token             <span class="built_in">BLOB</span> <span class="keyword">comment</span> <span class="string">&#x27;access_token序列化的二进制数据格式&#x27;</span>,</span><br><span class="line">    authentication_id <span class="built_in">VARCHAR</span>(<span class="number">256</span>) PRIMARY <span class="keyword">KEY</span> <span class="keyword">comment</span> <span class="string">&#x27;主键，其值是根据当前的username(如果有),client_id与scope通过MD5加密生成的,具体实现参见DefaultAuthenticationKeyGenerator&#x27;</span>,</span><br><span class="line">    user_name         <span class="built_in">VARCHAR</span>(<span class="number">256</span>),</span><br><span class="line">    client_id         <span class="built_in">VARCHAR</span>(<span class="number">256</span>),</span><br><span class="line">    <span class="keyword">authentication</span>    <span class="built_in">BLOB</span> <span class="keyword">comment</span> <span class="string">&#x27;将OAuth2Authentication对象序列化后的二进制数据&#x27;</span>,</span><br><span class="line">    refresh_token     <span class="built_in">VARCHAR</span>(<span class="number">256</span>) <span class="keyword">comment</span> <span class="string">&#x27;refresh_token的MD5加密后的数据&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>之后，我们需要添加自定义 client 信息。本次演示添加的 client 信息如下（依旧本着尽量能不配置就不配置的原则）：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> oauth_client_details (client_id, resource_ids, client_secret, <span class="keyword">scope</span>, authorized_grant_types, web_server_redirect_uri, authorities, access_token_validity, refresh_token_validity, additional_information, autoapprove) <span class="keyword">VALUES</span> (<span class="string">&#x27;gold&#x27;</span>, <span class="string">&#x27;res&#x27;</span>, <span class="string">&#x27;&#123;noop&#125;123456&#x27;</span>, <span class="string">&#x27;write&#x27;</span>, <span class="string">&#x27;client_credentials&#x27;</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明</p>
<ol>
<li>在官方给出的源码当中，是有对应的 <a href="https://github.com/spring-projects/spring-security-oauth/blob/master/spring-security-oauth2/src/test/resources/schema.sql">schema.sql</a> 文件，这里只创建涉及我们示例中需要的表</li>
<li>对两张表的操作，我们可以去看这两个类：JdbcClientDetailsService &amp; JdbcTokenStore</li>
<li>此外本示例，添加了 resource_ids ，注意在配置 <code>ResourceServerSecurityConfigurer</code> 中对应</li>
</ol>
</blockquote>
<h3 id="Pom"><a href="#Pom" class="headerlink" title="Pom"></a>Pom</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="认证服务器代码修改"><a href="#认证服务器代码修改" class="headerlink" title="认证服务器代码修改"></a>认证服务器代码修改</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAuthorizationServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAuthorizationServerConfigurer</span> <span class="keyword">extends</span> <span class="title">AuthorizationServerConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyAuthorizationServerConfigurer</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dataSource = dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(ClientDetailsServiceConfigurer clients)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        clients.jdbc(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthorizationServerEndpointsConfigurer endpoints)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        endpoints.tokenStore(<span class="keyword">new</span> JdbcTokenStore(dataSource));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码只显示改动的部分，修改 client 的配置和 tokenStore 的配置，都进行添加数据源即可</p>
<h3 id="请求-token"><a href="#请求-token" class="headerlink" title="请求 token"></a>请求 token</h3><p>下面的请求是在 postman 中进行的。 base_url 为设置的全局变量，实际为 <a href="http://127.0.0.1:8080/">http://127.0.0.1:8080</a></p>
<p><img src="http://qiniu.5ires.top/uPic/image-20200901102558730.png" alt="获取token"></p>
<h3 id="获取资源"><a href="#获取资源" class="headerlink" title="获取资源"></a>获取资源</h3><p><img src="http://qiniu.5ires.top/uPic/image-20200901102640629.png" alt="请求资源"></p>
<h3 id="观察数据库"><a href="#观察数据库" class="headerlink" title="观察数据库"></a>观察数据库</h3><p><img src="http://qiniu.5ires.top/uPic/image-20200901102741912.png" alt="token存储"></p>
<p>由于 token 在数据库是存储的是二进制形式，但是我们通过 client_id 数据，可以看出是我们刚刚请求的 client。</p>
<p>到此为止我们已经是实现了，把 client 及 token 信息存储到数据库了，这样更便于我们对 client 及 token 数据的管理。但是数据库存储明文密码是不安全，那么接下来，我们对 client_secret 进行加密。</p>
<h2 id="client-secret-加密"><a href="#client-secret-加密" class="headerlink" title="client_secret 加密"></a>client_secret 加密</h2><h3 id="配置-passwordEncoder"><a href="#配置-passwordEncoder" class="headerlink" title="配置 passwordEncoder"></a>配置 passwordEncoder</h3><p>SpringBoot Oauth 本身支持的加密算法有很多种，详细信息可以看类 <code>PasswordEncoderFactories</code> ，包括我们最常用的 MD5、SHA 等，我们使用 <a href="https://zh.wikipedia.org/wiki/Bcrypt">bcrypt 加密算法</a>， 那么直接配置支持全部算法的 passwordEncoder ，即 <code>DelegatingPasswordEncoder</code> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(ClientDetailsServiceConfigurer clients)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        	  		clients.jdbc(dataSource).passwordEncoder(PasswordEncoderFactories.createDelegatingPasswordEncoder());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="加密-client-secret"><a href="#加密-client-secret" class="headerlink" title="加密 client_secret"></a>加密 client_secret</h3><p>既然我们这次使用 bcrypt 加密， 直接可以找到 <code>BCryptPasswordEncoder</code> ，通过它可以给我们的密码进行加密，并把密码存储于数据库当中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NoArgsConstructor(access = AccessLevel.PRIVATE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PasswordEncodeUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BCryptPasswordEncoder bcryptEncoder = <span class="keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">bcryptEncode</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bcryptEncoder.encode(password);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">genOauthEncodePwd</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;bcrypt&#125;&quot;</span> + bcryptEncode(password);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String oriPwd = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line">        System.out.println(genOauthEncodePwd(oriPwd));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原密码：123456<br>加密后密码：{bcrypt}$2a$10$NPxtsEUMmBGTlzVXlT.scubSCXNEDlBAq2r2t7iQFB/.RaNBlh0nO</p>
<p><img src="http://qiniu.5ires.top/uPic/image-20200901113958428.png" alt="client_sercret 加密"></p>
<p><em>注意：加密密码的前缀 大括号 “{xxx}”，是指定算法名称。因为框架支持多种算法，那么必须需要带有算法前缀。</em></p>
<h3 id="请求获取-token"><a href="#请求获取-token" class="headerlink" title="请求获取 token"></a>请求获取 token</h3><p>下面的请求是在 postman 中进行的。 base_url 为设置的全局变量，实际为 <a href="http://127.0.0.1:8080/">http://127.0.0.1:8080</a></p>
<p><img src="http://qiniu.5ires.top/uPic/image-20200901114224122.png" alt="请求token"></p>
<h3 id="请求资源"><a href="#请求资源" class="headerlink" title="请求资源"></a>请求资源</h3><p><img src="http://qiniu.5ires.top/uPic/image-20200901114259361.png" alt="请求资源"></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文主要是以 client_credentials 的授权方式，把 client 和 token 信息存储在数据库当中，来方便我们管理。同时，为了保证密码的安全，我们把 client_secret 用 bcrypt 算法进行了加密操作，并存储到数据库当中。有了上一篇基础，这篇整体挺简单的吧，那同学们动起来，实现一下吧！</p>
<p><strong>个人水平有限，欢迎大家指正，一起交流哦<del>~</del></strong></p>
<p><strong>demo：<a href="https://github.com/goldpumpkin/learn-demo/tree/master/springboot-oauth">https://github.com/goldpumpkin/learn-demo/tree/master/springboot-oauth</a></strong> </p>
<p><em>Reference:</em></p>
<ol>
<li><a href="http://andaily.com/spring-oauth-server/db_table_description.html">spring-oauth-server 数据库表说明</a></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>SpringBoot-Oauth2.0（三） —— Token 的存储方案</title>
    <url>/2020/09/01/SpringBoot-oauth%20(%E4%B8%89)-%20Token%20%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p>上一篇，我们把 Token 放到了关系型数据库当中存储，如果你的系统对认证接口响应时间要求很高，那么在关系型数据库中，查询 Token，一定会是一个瓶颈。那么怎么办呢？如果仅从存储 Token 方面考虑，有什么可以替代关系型数据的存储呢？</p>
<a id="more"></a>

<h2 id="Token-存储的分析"><a href="#Token-存储的分析" class="headerlink" title="Token 存储的分析"></a>Token 存储的分析</h2><p>第一，一般关系型数据库中的数据会存放于磁盘当中的，时间主要消耗于 IO 操作。那我们把 Token 放到内存中就可以解决 IO 问题，顺便也减少了对数据库的网络请求，而在 SpringBoot Oauth 框架中默认就是存储就是在内存当中的。</p>
<p>第二，第一种方案是有缺陷的，现在大多是应用都是分布式架构，把 Token 存放于一台实例的内存，是非常不合理的。这时候需要一个性能很高的中间介质来替代关系型数据库，<a href="https://redis.io/topics/introduction">Redis</a> 就是一个很好的选择。一方面是因为 Redis 是基于内存操作的，性能非常出色；另一方面，Redis 可以设置过期时间， 正好符合 Token 定时过期的特性。</p>
<p>第三，还有没有其他方案呢？我们从另一个角度想想，我们为什么要存储 Token 呢？ 因为 Token 是系统发放的，是允许客户端访问系统的一种授权凭证，当客户端携带 Token 请求资源的时候，系统是需要验证 Token 是合法授权的，才允许客户端可以访问相关资源。那么我们是不是也可以这样理解，只要系统能够验证授权的 Token ，不存起来也是可以的。其实有一种 Token 可以做到不存储， token 本身就带有授权信息，系统只需要在内存中用对应的算法就可以验证 Token 是不是合法授权的 ，这种方式就是用 <a href="https://en.wikipedia.org/wiki/JSON_Web_Token">JWT</a> 。</p>
<blockquote>
<p><strong>JWT是什么？</strong></p>
<p>JSON Web Token(JWT)，是一种认证解决方案，客户端和服务器用 JWT 规定格式的 Token 进行身份认证交互。JWT 的格式分为三段，每段之间用「.」做间隔，并且每段包含了不同的信息，当然作用也不同。分别是：</p>
<p><strong>Header - 头部</strong><br>    数据格式：JSON 数据经过 Base64URL 编码<br>    信息：指定了加密类型及 Type 为 JWT</p>
<p><strong>Payload - 负载</strong><br>    数据格式：JSON 数据经过 Base64URL 编码<br>    信息：Client 的授权信息等</p>
<p><strong>Signature - 签名</strong><br>    说明：前两部分和约定好的秘钥经过指定加密算法生成，也叫<a href="https://zh.wikipedia.org/wiki/%E8%A8%8A%E6%81%AF%E9%91%91%E5%88%A5%E7%A2%BC">信息验证码 MAC </a>，防止数据篡改    </p>
</blockquote>
<p>以上我们提出了3种方案，来替代数据库存储 Token 。其中，第一种在第一篇文章中已经实践过了。那接下来，我们分别实践一下另外两种方案。</p>
<h2 id="Token-存储到-Redis"><a href="#Token-存储到-Redis" class="headerlink" title="Token 存储到 Redis"></a>Token 存储到 Redis</h2><h3 id="Pom"><a href="#Pom" class="headerlink" title="Pom"></a>Pom</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> &#123;<span class="string">redis</span> <span class="string">host</span>&#125;</span><br><span class="line">    <span class="attr">password:</span> &#123;<span class="string">redis</span> <span class="string">password</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="请求-Token"><a href="#请求-Token" class="headerlink" title="请求 Token"></a>请求 Token</h3><p><img src="http://qiniu.5ires.top/uPic/image-20200903180205938.png" alt="redis-请求token"></p>
<h3 id="Redis-中的-Token-数据"><a href="#Redis-中的-Token-数据" class="headerlink" title="Redis 中的 Token 数据"></a>Redis 中的 Token 数据</h3><p><img src="http://qiniu.5ires.top/uPic/image-20200903180425965.png" alt="redis-存储token"></p>
<p>可以看出数据库新增了4个 Key ，那他们的 Value 是什么呢？直接看数据，都是二进制数据，看不出来。那我们回到源码去找答案。找到类 OAuth2Authentication 的 storeAccessToken 方法，可以看出除了 Key 为 auth:token 的 Value 是OAuth2Authentication 实例的序列化二进制数据外，其他 Key 的 Value 都是 Token 对应的二进制数据。</p>
<p>那现在 Token 已经存到了我们预期的 Redis 当中了，最后再请求下资源，看是否可以通过，完整的验证下。</p>
<h3 id="请求资源"><a href="#请求资源" class="headerlink" title="请求资源"></a>请求资源</h3><p><img src="http://qiniu.5ires.top/uPic/image-20200903182015962.png" alt="redis-请求资源"></p>
<p>毫不意外和惊喜的接受预期的结果吧。</p>
<p>现在我们已经实现了把 Token 存储到 Redis 当中，其实和存储到数据库中的做法很像，更换 TokenStore 就好了。那我们继续实践下 JWT 方案吧。</p>
<h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><h3 id="Pom-1"><a href="#Pom-1" class="headerlink" title="Pom"></a>Pom</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.security<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-security-jwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><p>上面已经简单介绍过 JWT ，其中和配置相关我们要注意的是，我们需要约定一个秘钥并且指定 JWT 对应的算法。JWT 默认的算法是 HMACSHA256 ，在框架找到对应的验证器 <code>MacSigner</code> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 配置jwt相关</span></span><br><span class="line"><span class="comment">* 省略了一部分代码</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAuthorizationServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAuthorizationServerConfigurer</span> <span class="keyword">extends</span> <span class="title">AuthorizationServerConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 指定加密秘钥</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jwt.key:GoLdJwtKey&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String tokenSecretKey;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthorizationServerEndpointsConfigurer endpoints)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">				<span class="comment">// 指定 token 转化器</span></span><br><span class="line">        JwtAccessTokenConverter jwtAccessTokenConverter = <span class="keyword">new</span> JwtAccessTokenConverter();</span><br><span class="line">      	<span class="comment">// 设置加签秘钥</span></span><br><span class="line">        jwtAccessTokenConverter.setSigningKey(tokenSecretKey);</span><br><span class="line">      	<span class="comment">// 设置信息验证码校验器</span></span><br><span class="line">        jwtAccessTokenConverter.setVerifier(<span class="keyword">new</span> MacSigner(tokenSecretKey));</span><br><span class="line">        TokenStore tokenStore = <span class="keyword">new</span> JwtTokenStore(jwtAccessTokenConverter);</span><br><span class="line"></span><br><span class="line">        endpoints.accessTokenConverter(jwtAccessTokenConverter);</span><br><span class="line">        endpoints.tokenStore(tokenStore);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取-Token"><a href="#获取-Token" class="headerlink" title="获取 Token"></a>获取 Token</h3><p><img src="http://qiniu.5ires.top/uPic/image-20200904114623764.png" alt="jwt-获取token"></p>
<p>这个 Token 也太长了吧，完整 Token 如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOlsicmVzIl0sInNjb3BlIjpbIndyaXRlIl0sImV4cCI6MTU5OTIzNDM1OSwianRpIjoiYjQ2NmVkNDEtNWI1Ni00NDc2LWE4ZjctYjEwYjQ0MTFhNTViIiwiY2xpZW50X2lkIjoiZ29sZCJ9.P-510ioyW4mfjS_UFlCREqnCail2GfMHFx4Mc2Jjf4Q</span><br></pre></td></tr></table></figure>

<p>来一起看下这个 Token，确实有三段，前两段可以直接用 Base64URL 解码。那我们直接到 <a href="https://jwt.io/">JWT 官网</a>解码一下：</p>
<p><img src="http://qiniu.5ires.top/uPic/image-20200904115142148.png" alt="jwt-decode"></p>
<p>信息如图所示，看到了客户端的相关信息，这也是我们想要的 Token 本身已经承载了 Client 的相关授权信息。接下来继续完成我们的验证，请求一下资源看结果。</p>
<h3 id="请求资源-1"><a href="#请求资源-1" class="headerlink" title="请求资源"></a>请求资源</h3><p><img src="http://qiniu.5ires.top/uPic/image-20200904115634873.png" alt="jwt-请求资源"></p>
<p>很顺利，我们请求资源成功了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天我们的目的就是寻找替代数据库存储 Token 的方案，分析之后找出了3种方案，并分别进行了实践。如果你的应用是单机，那么 Token 直接用内存就可以，很方便。如果你的应用是分布式的，那么关系型数据库是一种选择，如果对性能要求很高，那就上 Redis 吧。不过 JWT 方案性能也很高，还不要存储，只是暴露了一些授权信息，你可以把 Token 生效时间控制一下，因为它颁发后就无法在服务器侧失效，生产用它也没有太大问题。具体情况具体分析后，再选择合适的方式存储 Token 吧。</p>
<p><strong>个人水平有限，欢迎大家指正，欢迎关注微信公众号「小黄的笔记」一起交流哦<del>~</del></strong><br><img src="http://qiniu.5ires.top/uPic/1598968637527.jpg" alt="小黄的笔记"></p>
<p><strong>demo：<a href="https://github.com/goldpumpkin/learn-demo/tree/master/springboot-oauth">https://github.com/goldpumpkin/learn-demo/tree/master/springboot-oauth</a></strong> </p>
]]></content>
  </entry>
  <entry>
    <title>Zuul 的源码分析</title>
    <url>/2020/07/21/Zuul%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>Zuul 的源码读过吗？让我们一起看看吧</p>
<a id="more"></a>

<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>明确Zuul的执行流程和重要类的分析</p>
<h2 id="Zuul过滤器的生命周期"><a href="#Zuul过滤器的生命周期" class="headerlink" title="Zuul过滤器的生命周期"></a>Zuul过滤器的生命周期</h2><p><img src="http://qiniu.5ires.top/uPic/view.png" alt="preview"></p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="zuul怎么拦截我们的请求？"><a href="#zuul怎么拦截我们的请求？" class="headerlink" title="zuul怎么拦截我们的请求？"></a>zuul怎么拦截我们的请求？</h3><p><code>ZuulServletFilter</code> - 继承 Filter | <code>ZuulServlet</code> - 继承 HttpServlet<br>可以通过这两个类，让Zuul接管请求。由于他们的逻辑基本一致，下面用<code>ZuulServletFilter</code>来分析</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Zuul核心处理类，拦截请求</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZuulServletFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ZuulRunner zuulRunner;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 省略...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">         		<span class="comment">// 初始化requests和responses到RequestContext中，详见ZuulRunner#init</span></span><br><span class="line">            init((HttpServletRequest) servletRequest, (HttpServletResponse) servletResponse);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              	<span class="comment">// 执行 filterType=pre 的过滤器</span></span><br><span class="line">                preRouting();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ZuulException e) &#123;</span><br><span class="line">                <span class="comment">// 执行 filterType=error 的过滤器</span></span><br><span class="line">                error(e);</span><br><span class="line">                postRouting();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Only forward onto to the chain if a zuul response is not being sent</span></span><br><span class="line">            <span class="keyword">if</span> (!RequestContext.getCurrentContext().sendZuulResponse()) &#123;</span><br><span class="line">                filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">	              <span class="comment">// 执行 filterType=route 的过滤器</span></span><br><span class="line">                routing();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ZuulException e) &#123;</span><br><span class="line">                error(e);</span><br><span class="line">                postRouting();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              	<span class="comment">// 执行 filterType=post 的过滤器</span></span><br><span class="line">                postRouting();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ZuulException e) &#123;</span><br><span class="line">                error(e);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            error(<span class="keyword">new</span> ZuulException(e, <span class="number">500</span>, <span class="string">&quot;UNCAUGHT_EXCEPTION_FROM_FILTER_&quot;</span> + e.getClass().getName()));</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          	<span class="comment">// 清空线程变量</span></span><br><span class="line">            RequestContext.getCurrentContext().unset();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上方法核心步骤：</p>
<ul>
<li><p>初始化请求上下文<code>RequestContext</code></p>
</li>
<li><p>执行 pre、route、post过滤器，如果有错，执行error过滤器</p>
</li>
</ul>
<p><code>ZuulRunner</code> - 初始化<code>RequestContext</code>中的requests和responses并转发Filter相关方法到<code>FilterProcessor</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZuulRunner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> bufferRequests;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化RequestContext：生成请求和响应wapper保存</span></span><br><span class="line"><span class="comment">     * RequestContext：继承了ConcurrentHashMap，是一个Map容器，主要存放请求、响应供ZuulFilters使用。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(HttpServletRequest servletRequest, HttpServletResponse servletResponse)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        RequestContext ctx = RequestContext.getCurrentContext();</span><br><span class="line">        <span class="keyword">if</span> (bufferRequests) &#123;</span><br><span class="line">            ctx.setRequest(<span class="keyword">new</span> HttpServletRequestWrapper(servletRequest));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ctx.setRequest(servletRequest);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ctx.setResponse(<span class="keyword">new</span> HttpServletResponseWrapper(servletResponse));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * executes &quot;post&quot; filterType  ZuulFilters</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ZuulException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postRoute</span><span class="params">()</span> <span class="keyword">throws</span> ZuulException </span>&#123;</span><br><span class="line">        FilterProcessor.getInstance().postRoute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 省略route() preRoute() error() 方法</span></span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<p>以上看出Zuul是通过<code>ZuulServletFilter</code>以filter的方式（或者以<code>ZuulServlet</code>以servlet的方式）拦截或者承接我们的请求，并在<code>doFilter</code>方法（<code>service</code>方法）中处理各种类型的ZuulFilters，并通过<code>ZuulRunner</code>转发到<code>FilterProcessor</code>中找到对应的filter并执行相关逻辑。整个大致流程比较简单清晰，类似于设计模式中的门面模式。</p>
<p>​    其中，<code>RequestContext</code>是存在<code>ThreadLocal</code>当中，可以注意到当Zuul处理完毕之后，会清空线程变量<code>RequestContext</code>,以防止内存泄露。</p>
<h3 id="FilterProcessor怎么找到相应ZuulFilters并执行呢？"><a href="#FilterProcessor怎么找到相应ZuulFilters并执行呢？" class="headerlink" title="FilterProcessor怎么找到相应ZuulFilters并执行呢？"></a><code>FilterProcessor</code>怎么找到相应ZuulFilters并执行呢？</h3><p><code>FilterProcessor</code> - 执行filters的核心类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 执行对应阶段ZuulFilters</span></span><br><span class="line"><span class="comment">* sType：即为filterType，例如&quot;post&quot;、&quot;pre&quot;、&quot;route&quot;、&quot;error&quot;</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">runFilters</span><span class="params">(String sType)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (RequestContext.getCurrentContext().debugRouting()) &#123;</span><br><span class="line">            Debug.addRoutingDebug(<span class="string">&quot;Invoking &#123;&quot;</span> + sType + <span class="string">&quot;&#125; type filters&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> bResult = <span class="keyword">false</span>;</span><br><span class="line">			  <span class="comment">// 获取已经注册了的ZuulFilters，根本是从FilterRegistry中获取。并且list是已经排好序的，</span></span><br><span class="line">  			<span class="comment">// 根据给定的filterOrder</span></span><br><span class="line">        List&lt;ZuulFilter&gt; list = FilterLoader.getInstance().getFiltersByType(sType);</span><br><span class="line">        <span class="keyword">if</span> (list != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">                ZuulFilter zuulFilter = list.get(i);</span><br><span class="line">                <span class="comment">// 执行ZuulFilter逻辑并</span></span><br><span class="line">                Object result = processZuulFilter(zuulFilter);</span><br><span class="line">                <span class="keyword">if</span> (result != <span class="keyword">null</span> &amp;&amp; result <span class="keyword">instanceof</span> Boolean) &#123;</span><br><span class="line">                    bResult |= ((Boolean) result);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 执行ZuulFilter，并把执行情况组合成ZuulFilterResult并返回</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">processZuulFilter</span><span class="params">(ZuulFilter filter)</span> <span class="keyword">throws</span> ZuulException </span>&#123;</span><br><span class="line">  <span class="comment">// 省略部分代码...</span></span><br><span class="line">  <span class="comment">// 具体执行在 ZuulFilter#runFilter</span></span><br><span class="line">  ZuulFilterResult result = filter.runFilter();</span><br><span class="line">  ExecutionStatus s = result.getStatus();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (s) &#123;</span><br><span class="line">    <span class="keyword">case</span> FAILED:</span><br><span class="line">      t = result.getException();</span><br><span class="line">      ctx.addFilterExecutionSummary(filterName, ExecutionStatus.FAILED.name(), execTime);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SUCCESS:</span><br><span class="line">      o = result.getResult();</span><br><span class="line">      ctx.addFilterExecutionSummary(filterName, ExecutionStatus.SUCCESS.name(), execTime);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">            </span><br><span class="line">  <span class="keyword">if</span> (t != <span class="keyword">null</span>) <span class="keyword">throw</span> t;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 统计每个filter的每次执行情况</span></span><br><span class="line">  usageNotifier.notify(filter, s);</span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上方法核心步骤：</p>
<ul>
<li><p>按序执行各阶段ZuulFilters</p>
</li>
<li><p>记录ZuulFilter执行结果</p>
</li>
<li><p>统计执行情况</p>
</li>
</ul>
<p><code>ZuulFilter</code> - 最基本的Filter抽象类，自定义的Filter是继承此Filter，<code>FilterProcessor</code>执行Filter最终会转发到此类的<code>runFilter</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ZuulFilterResult <span class="title">runFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 执行结果以及执行成功与否情况包装成ZuulFilterResult返回</span></span><br><span class="line">  ZuulFilterResult zr = <span class="keyword">new</span> ZuulFilterResult();</span><br><span class="line">  <span class="comment">// 此filter是已被archaius禁用 「archaius是netflix开源的动态属性配置框架」</span></span><br><span class="line">  <span class="keyword">if</span> (!isFilterDisabled()) &#123;</span><br><span class="line">    <span class="comment">// 执行自定filter的shouldFilter方法判断是否执行此filter</span></span><br><span class="line">    <span class="keyword">if</span> (shouldFilter()) &#123;</span><br><span class="line">      Tracer t = TracerFactory.instance().startMicroTracer(<span class="string">&quot;ZUUL::&quot;</span> + <span class="keyword">this</span>.getClass().getSimpleName());</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Object res = run();</span><br><span class="line">        zr = <span class="keyword">new</span> ZuulFilterResult(res, ExecutionStatus.SUCCESS);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        t.setName(<span class="string">&quot;ZUUL::&quot;</span> + <span class="keyword">this</span>.getClass().getSimpleName() + <span class="string">&quot; failed&quot;</span>);</span><br><span class="line">        zr = <span class="keyword">new</span> ZuulFilterResult(ExecutionStatus.FAILED);</span><br><span class="line">        zr.setException(e);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        t.stopAndLog();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      zr = <span class="keyword">new</span> ZuulFilterResult(ExecutionStatus.SKIPPED);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> zr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Zuul把ZuulFilters存储在类<code>FilterLoader</code>属性名为<code>hashFiltersByType</code>的<code>ConcurrentHashMap</code>中，key为filterType(eg: pre、route、post、error或者自定义)</p>
<p>那么问题来了，这些存在于<code>FilterLoader</code>的ZuulFilter是怎么加载进来的呢？</p>
<h3 id="ZuulFIlter的加载"><a href="#ZuulFIlter的加载" class="headerlink" title="ZuulFIlter的加载"></a>ZuulFIlter的加载</h3><p>通过层层搜索，找到类<code>FilterFileManager</code> ，在此类初始化的时候，会到指定路径下读取指定文件。同时在初始时，会创建守护线程来定时扫描加载文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterFileManager</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 省略代码...</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> pollingIntervalSeconds, String... directories)</span> <span class="keyword">throws</span> Exception, IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) INSTANCE = <span class="keyword">new</span> FilterFileManager();</span><br><span class="line">    INSTANCE.aDirectories = directories;</span><br><span class="line">    <span class="comment">// 守护线程的轮询间隔时间</span></span><br><span class="line">    INSTANCE.pollingIntervalSeconds = pollingIntervalSeconds;</span><br><span class="line">    <span class="comment">// 读取并处理文件</span></span><br><span class="line">    INSTANCE.manageFiles();</span><br><span class="line">    <span class="comment">// 开启文件扫描的守护线程</span></span><br><span class="line">    INSTANCE.startPoller();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">manageFiles</span><span class="params">()</span> <span class="keyword">throws</span> Exception, IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line">        <span class="comment">// 读取文件</span></span><br><span class="line">				List&lt;File&gt; aFiles = getFiles();</span><br><span class="line">    		<span class="comment">// 通过FilterLoader来处理文件</span></span><br><span class="line">        processGroovyFiles(aFiles);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 扫描指定目录下的指定类型文件</span></span><br><span class="line">  <span class="function">List&lt;File&gt; <span class="title">getFiles</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;File&gt; list = <span class="keyword">new</span> ArrayList&lt;File&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String sDirectory : aDirectories) &#123;</span><br><span class="line">      <span class="keyword">if</span> (sDirectory != <span class="keyword">null</span>) &#123;</span><br><span class="line">        File directory = getDirectory(sDirectory);</span><br><span class="line">        <span class="comment">// Zuul有自带类`GroovyFileFilter`是扫描 .groovy 文件.</span></span><br><span class="line">        File[] aFiles = directory.listFiles(FILENAME_FILTER);</span><br><span class="line">        <span class="keyword">if</span> (aFiles != <span class="keyword">null</span>) &#123;</span><br><span class="line">          list.addAll(Arrays.asList(aFiles));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 开启守护线程进行轮询</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">startPoller</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    poller = <span class="keyword">new</span> Thread(<span class="string">&quot;GroovyFilterFileManagerPoller&quot;</span>) &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (bRunning) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            sleep(pollingIntervalSeconds * <span class="number">1000</span>);</span><br><span class="line">            manageFiles();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    poller.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">    poller.start();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterLoader</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 处理文件</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">putFilter</span><span class="params">(File file)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String sName = file.getAbsolutePath() + file.getName();</span><br><span class="line">    <span class="comment">// 判断如果文件被修改过，则删除对应已经注册的filter</span></span><br><span class="line">    <span class="keyword">if</span> (filterClassLastModified.get(sName) != <span class="keyword">null</span> &amp;&amp; (file.lastModified() != filterClassLastModified.get(sName))) &#123;</span><br><span class="line">      LOG.debug(<span class="string">&quot;reloading filter &quot;</span> + sName);</span><br><span class="line">      filterRegistry.remove(sName);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ZuulFilter filter = filterRegistry.get(sName);</span><br><span class="line">    <span class="keyword">if</span> (filter == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 编译文件 - zuul自带GroovyCompiler编译groovy编写的文件</span></span><br><span class="line">      Class clazz = COMPILER.compile(file);</span><br><span class="line">      <span class="comment">// 如果不是抽象类即ZuulFilter，则进行实例化并放入内存</span></span><br><span class="line">      <span class="keyword">if</span> (!Modifier.isAbstract(clazz.getModifiers())) &#123;</span><br><span class="line">        filter = (ZuulFilter) FILTER_FACTORY.newInstance(clazz);</span><br><span class="line">        List&lt;ZuulFilter&gt; list = hashFiltersByType.get(filter.filterType());</span><br><span class="line">        <span class="keyword">if</span> (list != <span class="keyword">null</span>) &#123;</span><br><span class="line">          hashFiltersByType.remove(filter.filterType()); <span class="comment">//rebuild this list</span></span><br><span class="line">        &#125;</span><br><span class="line">        filterRegistry.put(file.getAbsolutePath() + file.getName(), filter);</span><br><span class="line">        filterClassLastModified.put(sName, file.lastModified());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上两个类核心步骤 即为 <code>FilterFileManager</code>初始化过程</p>
<ul>
<li>扫描指定目录下的groovy文件，通过<code>FilterLoader</code>编译文件，并加载ZuulFilter</li>
<li>开启守护进程，轮询文件，动态加载ZuulFilter</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p>Zuul的源码执行路径：</p>
<p><img src="http://qiniu.5ires.top/uPic/image-20200724141526966.png" alt="image-20200724141526966"></p>
</li>
<li><p>ZuulFilter的加载方式：是通过扫描<code>.groovy</code>文件来加载，并支持动态加载，具体可以看官方示例zuul-simple-webapp</p>
</li>
<li><p>Zuul的整个流程，是基于servlet或filter方式在service或doFilter方法中衔接请求，并运用类似<a href="https://zh.wikipedia.org/wiki/%E5%A4%96%E8%A7%80%E6%A8%A1%E5%BC%8F">门面模式</a>编写</p>
</li>
</ul>
<p>​      至此，Zuulfilter的加载以及各类型Filter的执行都在源码中找到了。zuul-core的代码还是很容易能看懂。下一篇，会分析SpringCloud怎么整合Zuul。</p>
]]></content>
  </entry>
  <entry>
    <title>Zuul 的路由匹配</title>
    <url>/2020/08/19/Zuul%E7%9A%84%E8%B7%AF%E7%94%B1%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<p>上一篇，我们已经知道了  Zuul 的配置，其中 Zuul 的路由匹配也是核心配置之一，那 Zuul 是怎么匹配我们的请求，从而让我们的请求进入到一系列的 ZuulFilter 呢？那就和我一起去刨一刨吧。</p>
<a id="more"></a>

<h2 id="Zuul的路由匹配规则是什么呢？"><a href="#Zuul的路由匹配规则是什么呢？" class="headerlink" title="Zuul的路由匹配规则是什么呢？"></a>Zuul的路由匹配规则是什么呢？</h2><p>拿出我的必杀器，DDDDebug 一下：</p>
<ol>
<li><p>Debug 显示匹配路由是先从 Spring 在<code>AbstractUrlHandlerMapping</code>匹配<code>HandlerExecutionChain</code>开始</p>
<p><img src="http://qiniu.5ires.top/uPic/image-20200819230258789.png" alt="Spring-Match-ZuulController"></p>
</li>
<li><p>之后进入到<code>ZuulFilter</code>的 Pre 类型的FIlter当中的<code>PreDecorationFilter</code> ，匹配对应的<code>ZuulRoute</code></p>
</li>
<li><p>首先把请求的路由修理一下，去掉context-path。就像例子当中，请求 url 中<code>/text/test</code> 去掉了 <code>/text</code>，再接着执行</p>
<p><img src="http://qiniu.5ires.top/uPic/image-20200819190711091.png" alt="去掉context-path"></p>
</li>
<li><p>之后进入到<code>SimpleRouteLocator</code>，判断是否属于 Zuul 忽略处理的请求，如果不是，再匹配对应<code>ZuulRoute</code>。这里可以发现匹配功能都是由<code>AntPathMatcher</code>来负责</p>
<p><img src="http://qiniu.5ires.top/uPic/image-20200819191434405.png" alt="SimpleRouteLocator匹配URL"></p>
</li>
</ol>
<p>那我们发现，不管是 Spring 的匹配 Handler 还是 <code>PreDecorationFilter</code> 匹配 <code>ZuulRoute</code>，都用到的是<code>AntPathMatcher</code>。那我们现在只需要搞明白<code>AntPathMatcher</code>匹配规则就好了。Go on!</p>
<h2 id="ANT-Style-Pattern"><a href="#ANT-Style-Pattern" class="headerlink" title="ANT Style Pattern"></a>ANT Style Pattern</h2><p>匹配规则如下：</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>?</td>
<td>匹配一个字符</td>
</tr>
<tr>
<td>*</td>
<td>匹配0个或者更多的字符</td>
</tr>
<tr>
<td>**</td>
<td>匹配路径中0个或者更多目录</td>
</tr>
</tbody></table>
<p>举例：</p>
<table>
<thead>
<tr>
<th>例子</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>com/t?st.jsp</code></td>
<td>可以匹配 com/test.jsp 或者 <code>com/tast.jsp</code> 或者 <code>com/txst.jsp </code> 等等</td>
</tr>
<tr>
<td><code>com/*.jsp</code></td>
<td>匹配到 com 目录下所有 .jsp 文件</td>
</tr>
<tr>
<td><code>com/**/test.jsp</code></td>
<td>匹配在 com 路径下，所有的 test.jsp 文件</td>
</tr>
<tr>
<td><code>org/springframework/**/*.jsp</code></td>
<td>匹配 org/springframework 路径下所有 .jsp文件</td>
</tr>
<tr>
<td><code>org/**/servlet/bla.jsp</code></td>
<td>可以匹配 org 路径下，后面多层目录且最后一个目录是 servlet/bla.jsp 的路径</td>
</tr>
</tbody></table>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实，刨下来 Zuul 的路由匹配还挺简单的，主要理解并掌握 Ant 的匹配规则就完事儿了。来动手试一试吧。</p>
<p>Demo地址是：<a href="https://github.com/goldpumpkin/learn-demo">https://github.com/goldpumpkin/learn-demo</a></p>
<p><em>Ref.</em><br><em><a href="https://stackoverflow.com/questions/2952196/learning-ant-path-style">stackoverflow-learning-ant-path-style</a></em></p>
<p><strong>我的个人水平有限，欢迎大家指正，欢迎交流~</strong></p>
]]></content>
  </entry>
  <entry>
    <title>Zuul 的配置</title>
    <url>/2020/08/06/Zuul%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>这一篇主要介绍Zuul的配置。为了大家快速上手，主要通过示例来演示如何进行Zuul配置。</p>
<a id="more"></a>

<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>配置可以分为几个部分：</p>
<p><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.4.RELEASE/reference/html/#netflix-zuul-starter">Zuul路由配置</a>：</p>
<ul>
<li><p>Zuul自己的配置对应的类是<code>ZuulProperties</code>，配置的前缀是<code>zuul</code></p>
</li>
<li><p>自定义的路由配置在代码中对应的是<code>ZuulProperties</code>的属性：<code>Map&lt;String, ZuulRoute&gt; routes = new LinkedHashMap&lt;&gt;()</code></p>
</li>
<li><p>routes是一个Map，key代表route名称，value是路由规则配置的详细信息</p>
</li>
</ul>
<p><a href="https://github.com/Netflix/ribbon/wiki/Getting-Started">Ribbon配置信息</a>：主要提供负载均衡、重试、超时等配置。配置类是<a href="http://netflix.github.io/ribbon/ribbon-core-javadoc/com/netflix/client/config/CommonClientConfigKey.html">CommonClientConfigKey</a>，其中要注意配置key是大小写敏感的！</p>
<p><a href="https://github.com/Netflix/Hystrix/wiki/Configuration#coreSize">Hytrix配置信息</a>：主要提供熔断策略、超时等配置</p>
<h2 id="路由配置分为两种"><a href="#路由配置分为两种" class="headerlink" title="路由配置分为两种"></a>路由配置分为两种</h2><ul>
<li>转发到物理地址</li>
<li>转发到服务</li>
</ul>
<h2 id="转发到物理路径的配置"><a href="#转发到物理路径的配置" class="headerlink" title="转发到物理路径的配置"></a>转发到物理路径的配置</h2><h3 id="配置说明"><a href="#配置说明" class="headerlink" title="配置说明"></a>配置说明</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">host:</span></span><br><span class="line">  	<span class="comment"># 链接超时时间</span></span><br><span class="line">    <span class="attr">connect-timeout-millis:</span> <span class="number">2000</span></span><br><span class="line">    <span class="comment"># socket超时时间</span></span><br><span class="line">    <span class="attr">socket-timeout-millis:</span> <span class="number">10000</span></span><br><span class="line">  <span class="comment"># routes 即为 Map&lt;String, ZuulRoute&gt; routes = new LinkedHashMap&lt;&gt;()</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">    <span class="comment"># route名称 - 是ZuulRoute属性中的id，也是Map中的key</span></span><br><span class="line">    <span class="attr">test:</span></span><br><span class="line">      <span class="comment"># 匹配路径模板</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/test/**</span></span><br><span class="line">      <span class="comment"># 请求转发到的服务id 和 url属性互斥，两个只能配置一个</span></span><br><span class="line">      <span class="comment"># 请求转发到的物理路径</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">http://127.0.0.1:9000</span> </span><br><span class="line">      <span class="comment"># 转发前是否跳过前缀,默认为true，前缀指的是：匹配路径的path前缀 or zuul.prefix定义</span></span><br><span class="line">      <span class="attr">stripPrefix:</span> <span class="literal">true</span></span><br><span class="line">      <span class="comment"># 敏感Header， 转发时会去掉敏感的头部信息，以下是默认的配置。</span></span><br><span class="line">      <span class="attr">sensitiveHeaders:</span> <span class="string">Cookie,Set-Cookie,Authorization</span></span><br></pre></td></tr></table></figure>

<h3 id="Example-1-最简洁配置"><a href="#Example-1-最简洁配置" class="headerlink" title="Example - 1 - 最简洁配置"></a>Example - 1 - 最简洁配置</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">    <span class="attr">test:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/test/**</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">http://127.0.0.1:9000</span> </span><br></pre></td></tr></table></figure>

<p>Request URL：<a href="http://127.0.0.1:8001/test">http://127.0.0.1:8001/test</a></p>
<p>Zuul Forward URL：<a href="http://127.0.0.1:9000/">http://127.0.0.1:9000/</a></p>
<h3 id="Example-2-试验其他配置-sensitiveHeaders-amp-stripPrefix"><a href="#Example-2-试验其他配置-sensitiveHeaders-amp-stripPrefix" class="headerlink" title="Example - 2 - 试验其他配置(sensitiveHeaders &amp; stripPrefix)"></a>Example - 2 - 试验其他配置(sensitiveHeaders &amp; stripPrefix)</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">    <span class="attr">test:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/test/**</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">http://127.0.0.1:9000</span> </span><br><span class="line">      <span class="attr">stripPrefix:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">sensitiveHeaders:</span> <span class="string">Test-Sensitive-Header</span></span><br></pre></td></tr></table></figure>

<p>Request:</p>
<ul>
<li>URL: <a href="http://127.0.0.1:8001/test">http://127.0.0.1:8001/test</a></li>
<li>Header: <ul>
<li>Test-Sensitive-Header : ThisIsSensitiveHeader</li>
<li>Test-nomal-Header: ThisIsNomalHeader</li>
</ul>
</li>
</ul>
<p>Zuul Forward：</p>
<ul>
<li>URL：<a href="http://127.0.0.1:9000/test">http://127.0.0.1:9000/test</a></li>
<li>Header:<ul>
<li>Test-Sensitive-Header - 是敏感Header不转发</li>
<li>Test-nomal-Header - 进行转发</li>
</ul>
</li>
</ul>
<p><img src="http://qiniu.5ires.top/uPic/image-20200816225825634.png" alt="Example2-route-matched"></p>
<p><img src="http://qiniu.5ires.top/uPic/image-20200816230622007.png" alt="Example2-请求情况"></p>
<h2 id="转发到Service的配置"><a href="#转发到Service的配置" class="headerlink" title="转发到Service的配置"></a>转发到Service的配置</h2><h3 id="配置说明-1"><a href="#配置说明-1" class="headerlink" title="配置说明"></a>配置说明</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 转发到某个的服务 - 这个服务可以是服务发现的服务，也可以配置物理地址</span></span><br><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">host:</span></span><br><span class="line">    <span class="attr">connect-timeout-millis:</span> <span class="number">2000</span></span><br><span class="line">    <span class="attr">socket-timeout-millis:</span> <span class="number">10000</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">    <span class="attr">test-service:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/test/**</span></span><br><span class="line">      <span class="comment"># 服务名称: 如果使用服务治理框架那么填写服务名称，否则自定义服务名称</span></span><br><span class="line">      <span class="attr">serviceId:</span> <span class="string">test-service</span></span><br><span class="line">      <span class="comment"># 是否开启重试，具体重试设置是在Ribbon的配置中设置</span></span><br><span class="line">      <span class="attr">retryable:</span> <span class="literal">true</span></span><br><span class="line">      <span class="string">...</span></span><br><span class="line">      </span><br><span class="line"><span class="comment"># hystrix配置：提供熔断配置</span></span><br><span class="line"><span class="attr">hystrix:</span></span><br><span class="line">  <span class="attr">command:</span></span><br><span class="line">    <span class="comment"># 服务名称：default or 自己的服务名称</span></span><br><span class="line">    <span class="attr">default:</span></span><br><span class="line">      <span class="attr">execution:</span></span><br><span class="line">        <span class="attr">isolation:</span></span><br><span class="line">          <span class="attr">thread:</span></span><br><span class="line">            <span class="attr">timeoutInMilliseconds:</span> <span class="number">3000</span></span><br><span class="line">            <span class="string">...</span></span><br><span class="line"></span><br><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">	<span class="comment"># 是否使用 Eureka</span></span><br><span class="line">  <span class="attr">eureka:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># 对实例重试的次数(不包括每个实例的首次的请求)</span></span><br><span class="line">  <span class="attr">MaxAutoRetries:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment"># 同一个服务 重试其他实例数量</span></span><br><span class="line">  <span class="comment"># eg: listOfServers: s1, s2, s3  当此配置为1，第一次访问s1, 请求重试只会在s1、s2中进行</span></span><br><span class="line">  <span class="attr">MaxAutoRetriesNextServer:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment"># 是否所有操作都允许重试。默认值为false</span></span><br><span class="line">  <span class="attr">OkToRetryOnAllOperations:</span> <span class="literal">true</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 服务的相关配置</span></span><br><span class="line"><span class="attr">test-service:</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="comment"># 在提供的server列表中获取服务实例</span></span><br><span class="line">    <span class="attr">NIWSServerListClassName:</span> <span class="string">com.netflix.loadbalancer.ConfigurationBasedServerList</span></span><br><span class="line">    <span class="attr">listOfServers:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:9000,</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:9001</span></span><br><span class="line">    <span class="string">...</span></span><br></pre></td></tr></table></figure>

<p>基本配置是和前面提到的转发到物理地址的配置是相同的，不同的是这里增加了Ribbon和Hytrix的相关配置。</p>
<p>匹配路由映射到服务，服务是由服务治理框架提供，如Eureka、Consul。之后通过Ribbon，进行负载均衡，Hytrix负责防护熔断。</p>
<p>所以说Zuul除了路由配置是自身提供的，其余的配置是由Ribbon和Hytrix提供的。</p>
<h3 id="Example-3-Ribbon的简单配置"><a href="#Example-3-Ribbon的简单配置" class="headerlink" title="Example - 3 - Ribbon的简单配置"></a>Example - 3 - Ribbon的简单配置</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">    <span class="attr">test-service:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/test/**</span></span><br><span class="line">      <span class="attr">serviceId:</span> <span class="string">test-service</span></span><br><span class="line">      <span class="attr">stripPrefix:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="attr">test-service:</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">listOfServers:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:9000</span></span><br></pre></td></tr></table></figure>

<p>Request URL：<a href="http://127.0.0.1:8001/test">http://127.0.0.1:8001/test</a><br>Zuul Forward URL：<a href="http://127.0.0.1:9000/test">http://127.0.0.1:9000/test</a></p>
<h3 id="Example-4-重试"><a href="#Example-4-重试" class="headerlink" title="Example - 4 - 重试"></a>Example - 4 - 重试</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">    <span class="attr">test-service:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/test/**</span></span><br><span class="line">      <span class="attr">serviceId:</span> <span class="string">test-service</span></span><br><span class="line">      <span class="attr">stripPrefix:</span> <span class="literal">false</span></span><br><span class="line">      <span class="comment"># 开启重试</span></span><br><span class="line">      <span class="attr">retryable:</span> <span class="literal">true</span></span><br><span class="line">      </span><br><span class="line"><span class="comment"># 具体重试规则在ribbon中配置</span></span><br><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">  <span class="attr">eureka:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">MaxAutoRetries:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">MaxAutoRetriesNextServer:</span> <span class="number">1</span></span><br><span class="line">  </span><br><span class="line"><span class="attr">test-service:</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">listOfServers:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:9000,</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:9001,</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:9002</span></span><br></pre></td></tr></table></figure>

<p>Request URL：<a href="http://127.0.0.1:8001/test">http://127.0.0.1:8001/test</a></p>
<p>第一步：</p>
<ul>
<li>转发到：<a href="http://127.0.0.1:9000/test">http://127.0.0.1:9000/test</a></li>
<li>返回：code: 500</li>
</ul>
<p><img src="http://qiniu.5ires.top/uPic/image-20200817190925927.png" alt="Example4-第一次请求到端口9000"></p>
<p>第二步：</p>
<ul>
<li>重试：<a href="http://127.0.0.1:9000/test">http://127.0.0.1:9000/test</a></li>
<li>返回：code: 500</li>
</ul>
<p><img src="http://qiniu.5ires.top/uPic/image-20200817191248495.png" alt="Example4-重试第一次端口号9001"></p>
<p>第三步和第四步：</p>
<ul>
<li>重试：<a href="http://127.0.0.1:9001/test">http://127.0.0.1:9001/test</a></li>
<li>返回：因为9001端口没有启动服务，返回没有连接</li>
</ul>
<p><img src="http://qiniu.5ires.top/uPic/image-20200817191521361.png" alt="Example4-重试转发至服务的另一个实例 端口号9001"></p>
<p>至此，本次请求，一共重试了3次。</p>
<p>测试代码：<a href="https://github.com/goldpumpkin/learn-demo">https://github.com/goldpumpkin/learn-demo</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Zuul的配置，包括了自己的路由配置、Ribbon配置以及Hytrix配置。其中路由配置分为两种，一种是把请求转发到物理地址，另一种是把请求转发到微服务。要想掌握和配置好Zuul，那么必须学习Ribbon和Hytrix，这样才能很好的驾驭Zuul。</p>
<p><strong>我的个人水平有限，欢迎大家指正，欢迎交流~</strong></p>
]]></content>
  </entry>
  <entry>
    <title>SpringCloud 整合 Zuul 源码分析</title>
    <url>/2020/07/21/SpringCloud%E6%95%B4%E5%90%88Zuul%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>今天我们分析下 SpringCloud 是怎么整合 Zuul 的。</p>
<a id="more"></a>

<h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><ol>
<li><p>Zuul是通过<code>ZuulServletFilter</code>或者 <code>ZuulServlet</code>接管我们的请求</p>
</li>
<li><p>Zuul整个流程如下：</p>
<p><code>ZuulServletFilter(ZuulServlet)</code> -&gt;  <code>ZuulRunner</code> -&gt; <code>FilterProcessor</code> -&gt; <code>ZuulFilter</code></p>
</li>
</ol>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>明确SpringMVC和Zuul框架是怎么配合的</p>
<h2 id="引入Zuul的版本信息"><a href="#引入Zuul的版本信息" class="headerlink" title="引入Zuul的版本信息"></a>引入Zuul的版本信息</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Hoxton.RELEASE<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-zuul<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="Zuul功能启用及配置的加载"><a href="#Zuul功能启用及配置的加载" class="headerlink" title="Zuul功能启用及配置的加载"></a>Zuul功能启用及配置的加载</h2><h3 id="Zuul的启用-EnableZuulProxy"><a href="#Zuul的启用-EnableZuulProxy" class="headerlink" title="Zuul的启用 - @EnableZuulProxy"></a>Zuul的启用 - @EnableZuulProxy</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入断路器功能</span></span><br><span class="line"><span class="meta">@EnableCircuitBreaker</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="comment">// 注入触发Zuul配置类的标记Bean</span></span><br><span class="line"><span class="meta">@Import(ZuulProxyMarkerConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableZuulProxy &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ZuulProxyAutoConfiguration-Zuul自动配置Bean"><a href="#ZuulProxyAutoConfiguration-Zuul自动配置Bean" class="headerlink" title="ZuulProxyAutoConfiguration - Zuul自动配置Bean"></a>ZuulProxyAutoConfiguration - Zuul自动配置Bean</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 此配置类不会被代理</span></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="comment">// 引入Ribbon相关配置</span></span><br><span class="line"><span class="meta">@Import(&#123; RibbonCommandFactoryConfiguration.RestClientRibbonConfiguration.class,</span></span><br><span class="line"><span class="meta">		RibbonCommandFactoryConfiguration.OkHttpRibbonConfiguration.class,</span></span><br><span class="line"><span class="meta">		RibbonCommandFactoryConfiguration.HttpClientRibbonConfiguration.class,</span></span><br><span class="line"><span class="meta">		HttpClientConfiguration.class &#125;)</span></span><br><span class="line"><span class="meta">@ConditionalOnBean(ZuulProxyMarkerConfiguration.Marker.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZuulProxyAutoConfiguration</span> <span class="keyword">extends</span> <span class="title">ZuulServerAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 省略部分代码。。。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 加载pre filters bean</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="meta">@ConditionalOnMissingBean(PreDecorationFilter.class)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> PreDecorationFilter <span class="title">preDecorationFilter</span><span class="params">(RouteLocator routeLocator,</span></span></span><br><span class="line"><span class="function"><span class="params">			ProxyRequestHelper proxyRequestHelper)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> PreDecorationFilter(routeLocator,</span><br><span class="line">				<span class="keyword">this</span>.server.getServlet().getContextPath(), <span class="keyword">this</span>.zuulProperties,</span><br><span class="line">				proxyRequestHelper);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 加载route filters bean</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="meta">@ConditionalOnMissingBean(RibbonRoutingFilter.class)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> RibbonRoutingFilter <span class="title">ribbonRoutingFilter</span><span class="params">(ProxyRequestHelper helper,</span></span></span><br><span class="line"><span class="function"><span class="params">			RibbonCommandFactory&lt;?&gt; ribbonCommandFactory)</span> </span>&#123;</span><br><span class="line">		RibbonRoutingFilter filter = <span class="keyword">new</span> RibbonRoutingFilter(helper, ribbonCommandFactory,</span><br><span class="line">				<span class="keyword">this</span>.requestCustomizers);</span><br><span class="line">		<span class="keyword">return</span> filter;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 加载route filters bean</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="meta">@ConditionalOnMissingBean(&#123; SimpleHostRoutingFilter.class,</span></span><br><span class="line"><span class="meta">			CloseableHttpClient.class &#125;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> SimpleHostRoutingFilter <span class="title">simpleHostRoutingFilter</span><span class="params">(ProxyRequestHelper helper,</span></span></span><br><span class="line"><span class="function"><span class="params">			ZuulProperties zuulProperties,</span></span></span><br><span class="line"><span class="function"><span class="params">			ApacheHttpClientConnectionManagerFactory connectionManagerFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">			ApacheHttpClientFactory httpClientFactory)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> SimpleHostRoutingFilter(helper, zuulProperties,</span><br><span class="line">				connectionManagerFactory, httpClientFactory);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ZuulServerAutoConfiguration-Zuul自动配置Bean"><a href="#ZuulServerAutoConfiguration-Zuul自动配置Bean" class="headerlink" title="ZuulServerAutoConfiguration - Zuul自动配置Bean"></a>ZuulServerAutoConfiguration - Zuul自动配置Bean</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="comment">// 加载zuul的自定义properties配置</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(&#123; ZuulProperties.class &#125;)</span></span><br><span class="line"><span class="comment">// 加载前提：classpath下有类ZuulServlet和ZuulServletFilter</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123; ZuulServlet.class, ZuulServletFilter.class &#125;)</span></span><br><span class="line"><span class="meta">@ConditionalOnBean(ZuulServerMarkerConfiguration.Marker.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZuulServerAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 省略部分代码。。。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// ZuulController是Controller的一个实现，负责将拦截的请求交给ZuulServlet处理</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> ZuulController <span class="title">zuulController</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ZuulController();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ZuulHandlerMapping负责路由匹配</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> ZuulHandlerMapping <span class="title">zuulHandlerMapping</span><span class="params">(RouteLocator routes,</span></span></span><br><span class="line"><span class="function"><span class="params">			ZuulController zuulController)</span> </span>&#123;</span><br><span class="line">		ZuulHandlerMapping mapping = <span class="keyword">new</span> ZuulHandlerMapping(routes, zuulController);</span><br><span class="line">		mapping.setErrorController(<span class="keyword">this</span>.errorController);</span><br><span class="line">		mapping.setCorsConfigurations(getCorsConfigurations());</span><br><span class="line">		<span class="keyword">return</span> mapping;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 默认加载ZuulServlet</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="meta">@ConditionalOnMissingBean(name = &quot;zuulServlet&quot;)</span></span><br><span class="line">	<span class="meta">@ConditionalOnProperty(name = &quot;zuul.use-filter&quot;, havingValue = &quot;false&quot;,</span></span><br><span class="line"><span class="meta">			matchIfMissing = true)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> ServletRegistrationBean <span class="title">zuulServlet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		ServletRegistrationBean&lt;ZuulServlet&gt; servlet = <span class="keyword">new</span> ServletRegistrationBean&lt;&gt;(</span><br><span class="line">				<span class="keyword">new</span> ZuulServlet(), <span class="keyword">this</span>.zuulProperties.getServletPattern());</span><br><span class="line">		<span class="comment">// The whole point of exposing this servlet is to provide a route that doesn&#x27;t</span></span><br><span class="line">		<span class="comment">// buffer requests.</span></span><br><span class="line">		servlet.addInitParameter(<span class="string">&quot;buffer-requests&quot;</span>, <span class="string">&quot;false&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> servlet;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当配置zuul.use-filter=true，加载zuulServletFilter, 表示用filter来拦截请求</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="meta">@ConditionalOnMissingBean(name = &quot;zuulServletFilter&quot;)</span></span><br><span class="line">	<span class="meta">@ConditionalOnProperty(name = &quot;zuul.use-filter&quot;, havingValue = &quot;true&quot;,</span></span><br><span class="line"><span class="meta">			matchIfMissing = false)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">zuulServletFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">final</span> FilterRegistrationBean&lt;ZuulServletFilter&gt; filterRegistration = <span class="keyword">new</span> FilterRegistrationBean&lt;&gt;();</span><br><span class="line">		filterRegistration.setUrlPatterns(</span><br><span class="line">				Collections.singleton(<span class="keyword">this</span>.zuulProperties.getServletPattern()));</span><br><span class="line">		filterRegistration.setFilter(<span class="keyword">new</span> ZuulServletFilter());</span><br><span class="line">		filterRegistration.setOrder(Ordered.LOWEST_PRECEDENCE);</span><br><span class="line">		<span class="comment">// The whole point of exposing this servlet is to provide a route that doesn&#x27;t</span></span><br><span class="line">		<span class="comment">// buffer requests.</span></span><br><span class="line">		filterRegistration.addInitParameter(<span class="string">&quot;buffer-requests&quot;</span>, <span class="string">&quot;false&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> filterRegistration;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在Zuul各阶段filter处理过程中捕获异常，SendErrorFilter会forward &quot;/error&quot; </span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> SendErrorFilter <span class="title">sendErrorFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> SendErrorFilter();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ZuulFilterConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注入Spring容器中的ZuulFilter类型所有的实现类，包括内置和自定义的Filter，内置的有10个</span></span><br><span class="line">		<span class="meta">@Autowired</span></span><br><span class="line">		<span class="keyword">private</span> Map&lt;String, ZuulFilter&gt; filters;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册ZuulFilter到FilterRegistry中</span></span><br><span class="line">		<span class="meta">@Bean</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> ZuulFilterInitializer <span class="title">zuulFilterInitializer</span><span class="params">(CounterFactory counterFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">				TracerFactory tracerFactory)</span> </span>&#123;</span><br><span class="line">			FilterLoader filterLoader = FilterLoader.getInstance();</span><br><span class="line">			FilterRegistry filterRegistry = FilterRegistry.instance();</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> ZuulFilterInitializer(<span class="keyword">this</span>.filters, counterFactory, tracerFactory,</span><br><span class="line">					filterLoader, filterRegistry);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上两个类，加载了Zuul的相关配置类：</p>
<ul>
<li><p>拦截请求：</p>
<ul>
<li>和SpringMVC结合的Bean：<code>ZuulController</code>、<code>ZuulHandlerMapping</code></li>
<li>通过Web Filter拦截请求Bean：<code>ZuulServletFilter</code></li>
</ul>
</li>
<li><p>Zuul流程需要的Bean：</p>
<ul>
<li><p>自带的ZuulFilter，有10个下面会一一介绍</p>
</li>
<li><p>监控相关</p>
</li>
<li><p>ZuulFilter的容器：<code>FilterRegistry</code></p>
</li>
</ul>
</li>
</ul>
<h3 id="默认的ZuulFilters"><a href="#默认的ZuulFilters" class="headerlink" title="默认的ZuulFilters"></a>默认的ZuulFilters</h3><h3 id="Pre-Filter"><a href="#Pre-Filter" class="headerlink" title="Pre Filter"></a>Pre Filter</h3><ol>
<li><p><code>ServletDetectionFilter</code>  order = -3</p>
<p>作用：判断请求是否是由<code>DispatcherServlet</code> or  <code>ZuulServlet</code>传来的，并把判断结果以键值对的形式放在<code>RequestContext</code></p>
</li>
<li><p><code>Servlet30WrapperFilter</code> order = -2</p>
<p>作用：包装request，兼容servlet3.0</p>
</li>
<li><p><code>FormBodyWrapperFilter</code> order = -1</p>
<p>作用：包装表单数据并为下游服务重新编码</p>
</li>
<li><p><code>DebugFilter</code> order = 1</p>
<p>作用：如果debug请求，那么会在<code>RequestContext</code>中标记为debug请求和routing</p>
</li>
<li><p><code>PreDecorationFilter</code> = 5</p>
<p>作用：请求路由和zuul路由配置进行匹配，并设置与代理相关的头部信息</p>
</li>
</ol>
<h3 id="Route-Filter"><a href="#Route-Filter" class="headerlink" title="Route Filter"></a>Route Filter</h3><ol>
<li><p><code>RibbonRoutingFilter</code> order = 10</p>
<p>作用：使用Ribbon、Hytrix和可插拔的httpClient发送请求，serviceId、是否重试以及负载均衡策略在相关联的<code>RequestContext</code>获取</p>
</li>
<li><p><code>SimpleHostRoutingFilter</code>  order = 100</p>
<p>作用：用HttpClient发送请求到预定的URLs，URLs通过<code>RequestContext#getRouteHost()</code>获取</p>
</li>
<li><p><code>SendForwardFilter</code> order = 500</p>
<p>作用：用<code>RequestDispatcher</code>forwards请求，转发的地址是<code>RequestContext</code>的<code>FilterConstants#FORWARD_TO_KEY</code>对应value</p>
</li>
</ol>
<h3 id="Post-Filter"><a href="#Post-Filter" class="headerlink" title="Post Filter"></a>Post Filter</h3><ol>
<li><p><code>SendResponseFilter</code> order = 1000</p>
<p>作用：写 代理的请求得到的响应 到 当前响应</p>
</li>
</ol>
<h3 id="Error-Filter"><a href="#Error-Filter" class="headerlink" title="Error Filter"></a>Error Filter</h3><ol>
<li><p><code>SendErrorFilter</code>  order = 0</p>
<p>作用：如果<code>RequestContext#getThrowable()</code> 不为空，默认将请求转发到 /error</p>
</li>
</ol>
<h2 id="SpringMVC怎么把请求转发给Zuul？"><a href="#SpringMVC怎么把请求转发给Zuul？" class="headerlink" title="SpringMVC怎么把请求转发给Zuul？"></a>SpringMVC怎么把请求转发给Zuul？</h2><h3 id="从配置类分析"><a href="#从配置类分析" class="headerlink" title="从配置类分析"></a>从配置类分析</h3><p>从上述配置可以看下几个重要的配置类源码：</p>
<h4 id="ZuulController"><a href="#ZuulController" class="headerlink" title="ZuulController"></a><code>ZuulController</code></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZuulController</span> <span class="keyword">extends</span> <span class="title">ServletWrappingController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ZuulController</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置Servlet的类型</span></span><br><span class="line">		setServletClass(ZuulServlet.class);</span><br><span class="line">		setServletName(<span class="string">&quot;zuul&quot;</span>);</span><br><span class="line">		setSupportedMethods((String[]) <span class="keyword">null</span>); <span class="comment">// Allow all</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handleRequest</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">			HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// We don&#x27;t care about the other features of the base class, just want to</span></span><br><span class="line">			<span class="comment">// handle the request</span></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">super</span>.handleRequestInternal(request, response);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="comment">// @see com.netflix.zuul.context.ContextLifecycleFilter.doFilter</span></span><br><span class="line">			RequestContext.getCurrentContext().unset();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ServletWrappingController"><a href="#ServletWrappingController" class="headerlink" title="ServletWrappingController"></a><code>ServletWrappingController</code></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletWrappingController</span> <span class="keyword">extends</span> <span class="title">AbstractController</span> <span class="keyword">implements</span> <span class="title">BeanNameAware</span>, <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 省略代码。。</span></span><br><span class="line">  </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.servletClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;&#x27;servletClass&#x27; is required&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.servletName == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">this</span>.servletName = <span class="keyword">this</span>.beanName;</span><br><span class="line">			&#125;</span><br><span class="line">      <span class="comment">// 通过反射 初始化servlet</span></span><br><span class="line">			<span class="keyword">this</span>.servletInstance = ReflectionUtils.accessibleConstructor(<span class="keyword">this</span>.servletClass).newInstance();</span><br><span class="line">			<span class="keyword">this</span>.servletInstance.init(<span class="keyword">new</span> DelegatingServletConfig());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 通过servlet实例处理请求</span></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">protected</span> ModelAndView <span class="title">handleRequestInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">			Assert.state(<span class="keyword">this</span>.servletInstance != <span class="keyword">null</span>, <span class="string">&quot;No Servlet instance&quot;</span>);</span><br><span class="line">			<span class="keyword">this</span>.servletInstance.service(request, response);</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ZuulHandlerMapping"><a href="#ZuulHandlerMapping" class="headerlink" title="ZuulHandlerMapping"></a><code>ZuulHandlerMapping</code></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZuulHandlerMapping</span> <span class="keyword">extends</span> <span class="title">AbstractUrlHandlerMapping</span> </span>&#123;</span><br><span class="line">  	<span class="keyword">private</span> <span class="keyword">final</span> ZuulController zuul;</span><br><span class="line">  	<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> dirty = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据寻找路由处理器</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> Object <span class="title">lookupHandler</span><span class="params">(String urlPath, HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.errorController != <span class="keyword">null</span> &amp;&amp; urlPath.equals(<span class="keyword">this</span>.errorController.getErrorPath())) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="comment">// 如果属于配置的忽视路由，则返回null</span></span><br><span class="line">		<span class="keyword">if</span> (isIgnoredPath(urlPath, <span class="keyword">this</span>.routeLocator.getIgnoredPaths())) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		RequestContext ctx = RequestContext.getCurrentContext();</span><br><span class="line">		<span class="keyword">if</span> (ctx.containsKey(<span class="string">&quot;forward.to&quot;</span>)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.dirty) &#123;</span><br><span class="line">      <span class="comment">// dirty默认为true，第一次会触发注册处理器到Spring容器中</span></span><br><span class="line">      <span class="comment">// 或者发送zuul路由刷新事件，设置dirty为true，见ZuulRefreshListener</span></span><br><span class="line">			<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (<span class="keyword">this</span>.dirty) &#123;</span><br><span class="line">					registerHandlers();</span><br><span class="line">					<span class="keyword">this</span>.dirty = <span class="keyword">false</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="comment">// 交给Spring查找路由对应的handler</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.lookupHandler(urlPath, request);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注册配置路由对应的处理器</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerHandlers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Collection&lt;Route&gt; routes = <span class="keyword">this</span>.routeLocator.getRoutes();</span><br><span class="line">		<span class="keyword">if</span> (routes.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">this</span>.logger.warn(<span class="string">&quot;No routes found from RouteLocator&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> (Route route : routes) &#123;</span><br><span class="line">        <span class="comment">// 在Spring容器中注册zuul路由配置对应ZuulController处理器</span></span><br><span class="line">				registerHandler(route.getFullPath(), <span class="keyword">this</span>.zuul);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上配置类：</p>
<ul>
<li><code>ZuulController</code>：它是<code>ServletWrappingController</code>的 子类，将请求给到<code>ZuulServlet</code>去处理</li>
<li><code>ZuulHandlerMapping</code>：它是<code>AbstractUrlHandlerMapping</code>的子类，将请求路由到<code>ZuulController</code>处理</li>
<li><code>ZuulServlet</code>：由上一篇知道它是Zuul流程的入口之一</li>
</ul>
<blockquote>
<p>回顾SpingMVC对于请求的处理流程</p>
<ol>
<li>客户端请求交给SpringMVC的<code>DispatcherServlet</code>统一处理</li>
<li>通过已经注册的<code>HandlerMapping</code>, 根据请求路由找到处理器执行链<code>HandlerExecutionChain</code>，包括请求各个拦截器<code>HandlerInterceptor</code>和请求处理器<code>handler</code></li>
<li>找到请求处理器对应的适配器<code>HandlerAdapter</code></li>
<li>执行已注册的各拦截器的<code>preHandle</code>方法</li>
<li>调用处理器处理请求，返回模型数据以及视图<code>ModelAndView</code></li>
<li>执行已注册的各拦截器的<code>postHandle</code>方法</li>
<li>根据给定的<code>ModelAndView</code>进行渲染</li>
<li>响应客户端</li>
</ol>
</blockquote>
<p>结合SpingMVC对于请求的处理流程可以猜到，当请求给到SpringMVC的<code>DispatcherServlet</code>后，如果该路由是需要Zuul拦截的请求，那么会匹配到<code>ZuulHandlerMapping</code>，从而找到处理器<code>ZuulController</code>，之后在处理的时候，会交给<code>ZuulServlet</code>，后面的流程见上一篇文章。</p>
<h3 id="Debug验证"><a href="#Debug验证" class="headerlink" title="Debug验证"></a>Debug验证</h3><p>zuul拦截配置：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># zuul</span></span><br><span class="line"><span class="comment"># 是否启用ZuulServletFilter</span></span><br><span class="line"><span class="comment"># zuul.use-filter=true</span></span><br><span class="line"><span class="meta">ribbon.ConnectTimeout</span> = <span class="string">30000</span></span><br><span class="line"><span class="meta">ribbon.ReadTimeout</span> = <span class="string">30000</span></span><br><span class="line"><span class="meta">ribbon.eureka.enabled</span> = <span class="string">false</span></span><br><span class="line"></span><br><span class="line"><span class="meta">management.endpoints.web.exposure.include</span> = <span class="string">*</span></span><br><span class="line"><span class="meta">zuul.routes.test.path</span> = <span class="string">/test/**</span></span><br><span class="line"><span class="meta">zuul.routes.test.stripPrefix</span> = <span class="string">false</span></span><br><span class="line"><span class="meta">test.ribbon.listOfServers</span> = <span class="string">$&#123;service.test&#125;</span></span><br><span class="line"><span class="meta">service.test</span>=<span class="string">http://127.0.0.1:8081/t/test</span></span><br></pre></td></tr></table></figure>

<p>请求：<code>curl -v http://127.0.0.1:8080/test</code></p>
<p>图示过程：</p>
<p><img src="http://qiniu.5ires.top/uPic/image-20200724183906920.png" alt="image-20200724183906920"></p>
<p><img src="http://qiniu.5ires.top/uPic/image-20200724184049891.png" alt="image-20200724184049891"></p>
<p>结果显示：猜想是正确的。<br>大致流程：<code>DispatcherServlet</code> -&gt; <code>ZuulController</code> -&gt; <code>ZuulServlet</code> -&gt; 执行各阶段<code>ZuulFilters</code></p>
<p><img src="http://qiniu.5ires.top/uPic/ZuulServlet%E6%8E%A5%E7%AE%A1%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="image-20200803183334690"></p>
<h2 id="ZuulServletFilter-另一种拦截请求流程"><a href="#ZuulServletFilter-另一种拦截请求流程" class="headerlink" title="ZuulServletFilter - 另一种拦截请求流程"></a>ZuulServletFilter - 另一种拦截请求流程</h2><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在类ZuulServerAutoConfiguration中加载</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(name = &quot;zuulServletFilter&quot;)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(name = &quot;zuul.use-filter&quot;, havingValue = &quot;true&quot;,</span></span><br><span class="line"><span class="meta">		matchIfMissing = false)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">zuulServletFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> FilterRegistrationBean&lt;ZuulServletFilter&gt; filterRegistration = <span class="keyword">new</span> FilterRegistrationBean&lt;&gt;();</span><br><span class="line">   <span class="comment">// URL匹配规则: /zuul</span></span><br><span class="line">	filterRegistration.setUrlPatterns(</span><br><span class="line">			Collections.singleton(<span class="keyword">this</span>.zuulProperties.getServletPattern()));</span><br><span class="line">	filterRegistration.setFilter(<span class="keyword">new</span> ZuulServletFilter());</span><br><span class="line">	filterRegistration.setOrder(Ordered.LOWEST_PRECEDENCE);</span><br><span class="line">	filterRegistration.addInitParameter(<span class="string">&quot;buffer-requests&quot;</span>, <span class="string">&quot;false&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> filterRegistration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ZuulServletFilter</code>的URL匹配规则是<code>/zuul</code>, 而且如果要是使得<code>ZuulServletFilter</code>Bean加载，必须在配置文件中，添加：<code>zuul.use-filter=true</code>，如图：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 是否启用filter拦截</span></span><br><span class="line"><span class="meta">zuul.use-filter</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">zuul.routes.test.path</span> = <span class="string">/zuul/test/**</span></span><br><span class="line"><span class="meta">zuul.routes.test.stripPrefix</span> = <span class="string">false</span></span><br><span class="line"><span class="meta">test.ribbon.listOfServers</span> = <span class="string">$&#123;service.test&#125;</span></span><br><span class="line"><span class="meta">service.test</span>=<span class="string">http://127.0.0.1:8081</span></span><br></pre></td></tr></table></figure>

<h3 id="ZuulServletFilter源码"><a href="#ZuulServletFilter源码" class="headerlink" title="ZuulServletFilter源码"></a>ZuulServletFilter源码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZuulServletFilter</span> <span class="keyword">extends</span> <span class="title">com</span>.<span class="title">netflix</span>.<span class="title">zuul</span>.<span class="title">filters</span>.<span class="title">ZuulServletFilter</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse,</span></span></span><br><span class="line"><span class="function"><span class="params">			FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">		RequestContext context = RequestContext.getCurrentContext();</span><br><span class="line">		context.setZuulEngineRan();</span><br><span class="line">		<span class="keyword">super</span>.doFilter(servletRequest, servletResponse, filterChain);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码很简单，在请求上下文添加了一个标志位<code>zuulEngineRan</code>为true。并执行父类<code>com.netflix.zuul.filters.ZuulServletFilter</code>的<code>doFilter</code>方法，进而进入了Zuul的核心流程当中，后面的流程我们已经熟悉了。</p>
<p>其中要注意下，<code>com.netflix.zuul.filters.ZuulServletFilter</code>虽然是Filter，但是并没有在其<code>doFilter</code>方法中调用<code>FilterChain</code>的<code>doFilter</code>方法，我们可以回想下，如果是我们自己写FIlter，一定会调用。之所以<code>ZuulServletFilte</code>没有这么做，是因为它要接管请求，并不要Servlet来处理。</p>
<p><img src="http://qiniu.5ires.top/uPic/ZuulServletFilter.png" alt="image-20200803183210907"></p>
<p>大致流程如图：</p>
<p><img src="http://qiniu.5ires.top/uPic/ZuulServletFilter%E6%8E%A5%E7%AE%A1%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="image-20200803183440164"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Zuul和Spring结合并接管请求主要有两种方式：</p>
<ul>
<li>在Spring容器中通过注册请求处理器<code>ZuulController</code>和路由处理器的映射<code>ZuulHandlerMapping</code>，做到请求的拦截，并内置了一些ZuulFIlter保证请求的处理。</li>
<li>通过注册<code>ZuulServletFilter</code>,使用Filter方式接管请求，注意默认的路径匹配及生效配置</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>怎么写可测试代码？为什么写可测试代码是重要的呢？</title>
    <url>/2020/09/25/%E3%80%90%E8%AF%91%E3%80%91%E6%80%8E%E4%B9%88%E5%86%99%E5%A5%BD%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%8F%8A%E5%85%B6%E9%87%8D%E8%A6%81%E6%80%A7/</url>
    <content><![CDATA[<p>最近 leader 在要求每次开发新需求时同时要编写单元测试，之前很少会写单元测试，对单元测试的理解比较浅，刚好看到一篇介绍比较细致的文章。那就容我用蹩脚的英语翻译一下（英文很棒的同学直接到本文尾部访问原文链接吧），和大家一起讨论学习下。</p>
<a id="more"></a>

<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>单元测试是任何一个有态度的软件开发工程师的工具箱中必备的工具。然而，有时候对一段特定的代码，编写一个好的单元测试是一件让人头疼的事情。开发人员在自测或者测试其他人代码遇到困难时，他们常常认为，由于自身缺乏一些基本的测试知识或者没有掌握单元测试技巧导致的。</p>
<p>在这篇单元测试教程中，我要证明一下写好单元测试是非常容易的。其实，使得单元测试变得复杂化，或者说给单元测试带来昂贵复杂性的是，代码的不良设计和不可测试性。接下来，我们将讨论，是什么使得代码变的很难测试，而为了提高的代码可测试性，我们又该怎么避免那些反模式和不良实践呢，最后我们聊一下，通过编写可测试代码会给我们带来其他哪些好处。我们将看到，编写单元测试和生成可测试代码不仅仅是为了减少测试的麻烦，也是为了使得代码本身变得更加健壮和更易于维护。</p>
<p><img src="http://qiniu.5ires.top/uPic/toptal-blog-image-1434578005589-4e6897ec04cc0b3c7075b9b011ee915c.gif" alt="UT-1"></p>
<h2 id="什么是单元测试？"><a href="#什么是单元测试？" class="headerlink" title="什么是单元测试？"></a>什么是单元测试？</h2><p>本质上，一个单元测试就是我们应用程序的一个方法，这个方法的行为可以<strong>独立于应用的其他部分</strong>被验证。一个典型单元测试包括三个阶段：首先，初始化要测试应用程序的一小部分（也称为<a href="https://zh.wikipedia.org/zh-hans/%E8%A2%AB%E6%B5%8B%E7%B3%BB%E7%BB%9F">被测系统</a>，即 SUT）。然后，对被测系统应用一些刺激（通常对其调用一个方法）。最后，观察被测系统的行为结果。如果行为结果和预期的保持一致，那么单元测试通过。否则，不通过，同时表明了被测系统中存在问题。这三个测试阶段也成称为：Arrange、Act 和 Assert，简称 AAA。</p>
<p>单元测试可以验证被测系统的不同方面的行为，但大体上行为可以分为两类：<em>基于状态</em>的或者是<em>基于交互</em>的。验证被测系统是否产生正确的结果，称为<strong>基于状态</strong>的单元测试。验证被测系统是否正确调用某些方法，称为<strong>基于交互</strong>的单元测试</p>
<p>现在就换一种方式来解释下软件的单元测试。想象有一个疯狂的科学家，想构造一些超自然的<a href="https://zh.wikipedia.org/wiki/%E5%B5%8C%E5%90%88%E9%AB%94">生物嵌合体</a>，材料包括青蛙腿、章鱼触角、鸟翅膀和狗头（这个比喻非常贴近程序员在日常中的实际工作）。那这个科学家如何保证他挑选的每个生物单元都能正常工作呢？他可以做一些小试验，比方说，拿一只青蛙的腿，对它施加电刺激，然后检查肌肉是否适当收缩。其实他现在所做的基本上与单元测试的 Arrange-Act-Assert 步骤是相同的；唯一的区别是，在这种情况下，单元指的是物理对象，而不是我们用来构建程序的抽象对象。</p>
<p><img src="http://qiniu.5ires.top/uPic/image-20200929142032175.png" alt="UT-Crazy-1"></p>
<p>如下是一个简单的单元测试（英文原文是用 c# 编写的示例，本文大部分用 java 来编写示例）</p>
<p><img src="http://qiniu.5ires.top/uPic/image-20200925170621777.png" alt="unit test simple example"></p>
<h2 id="单元测试-vs-集成测试"><a href="#单元测试-vs-集成测试" class="headerlink" title="单元测试 vs 集成测试"></a>单元测试 vs 集成测试</h2><p>另一个需要考虑的重要问题是单元测试和集成测试之间的区别。</p>
<p>软件工程中的单元测试的目的是验证独立于应用其他部分的代码行为。单元测试的代码范围很窄小，这样就允许我们覆盖所有情况，以确保每个部分都能正确工作。</p>
<p>另一方面，集成测试则演示的是，系统的不同部分在实际环境中协同工作的情况。验证的场景相对比较复杂，一般需要借助外部资源，比如数据库或web服务器等。</p>
<p>让我们回到疯狂科学家的比喻中，设想他现在已经成功地将各个生物器官结合起来了。他想对这个组合好的生物体进行测试。比如，验证这个生物体可以在不同地形上行走。那么他首先需要建立一个生物可以行走的环境。之后，把组合生物体扔进去，用棍子戳他，观察它是否按照预想的设计行走和移动。在完成测试后，疯狂的科学家还需要清理他可爱的实验室里所有散落的泥土、沙子和岩石。</p>
<p><img src="http://qiniu.5ires.top/uPic/image-20200929142259927.png" alt="UT-Crazy-2"></p>
<p>请注意单元测试和集成测试之间的显著区别是：<em>单元测试是验证应用程序中一小部分的行为，独立于环境和其他部分，并且非常容易实现；而集成测试则涵盖了在接近真实生活环境中的不同组件之间的交互，并且需要更多的工作，包括额外的安装和拆卸阶段。</em></p>
<p>合理的结合单元测试和集成测试可以确保，每个单元都能独立于其他单元正常工作，并且所有这些单元在集成时都能很好地发挥作用，这让我们对整个系统在生产环境中正常运行有了很大的信心。 </p>
<h2 id="什么是好的单元测试？"><a href="#什么是好的单元测试？" class="headerlink" title="什么是好的单元测试？"></a>什么是好的单元测试？</h2><p>在深入学习本教程的主要部分，进行编写单元测试之前，让我们先快速讨论一下，一个好的单元测试应该具备哪些属性。一个好单元测试应该具备以下属性：</p>
<ul>
<li><p><strong>易写</strong></p>
<p>开发人员通常编写大量的单元测试，来覆盖应用的可能出现的不同行为和不同方面。这就要求单测是不需要花费程序员大量精力就可以轻松编写的。</p>
</li>
<li><p><strong>可读性</strong></p>
<p>单元测试的目的应该是明确的。单元测试描述的是我们应用中某个行为的影响，因此一个好的单元测试应该很容易让人理解正在测试的是哪种场景。如果单测失败，也很容易知道问题点在哪里。一个好的单元测试，让我们可以在不 debug 的情况下修复错误！</p>
</li>
<li><p><strong>可靠</strong></p>
<p>单测只有在系统有 bug 的情况下才会失败。虽然这看起来很明显，但是有些程序经常即使没有bug，也出现测试失败的情况。例如，测试可能在某个运行时通过，但是在运行整个测试套件时失败，或者是在开发环境单测通过，但是在集成环境中单测失败。这些情况表明单测存在设计缺陷。好的单元测试是可以重复执行的，并且不受环境或运行顺序等外部因素的影响。</p>
</li>
<li><p><strong>运行快</strong></p>
<p>开发人员编写单元测试是为了重复执行，以检测新代码是否引入了新的 bug。如果单元测试很慢，开发人员很可能不会在他们的机器上运行单元测试。一个慢的单测，可能不会造成很大的影响，但是一千个慢的单测，那将会浪费很多时间了。慢的单测可能还表明了被测系统和单测本身可能和外部系统产生了交互，单测可能依赖外部因素。</p>
</li>
<li><p><strong>真单元，非集成</strong></p>
<p>正如我们刚刚已经讨论过的，单元测试和集成测试有不同的目的，我们要区分开。单元测试和被测系统都不应访问网络资源、数据库和文件系统等，避免受到外部因素的影响。</p>
</li>
</ul>
<p>这就是单元测试，<em>并没有什么秘密</em>。此外，还有一些编写单元测试的技巧。</p>
<h2 id="可测试和不可测试代码"><a href="#可测试和不可测试代码" class="headerlink" title="可测试和不可测试代码"></a>可测试和不可测试代码</h2><p>有些的代码的编写方式使得为其写一个好的单测是很困难的。那么，是什么让代码变得难以测试呢？让我们回顾一下我们在编写代码时候，应该避免的反模式、代码坏味道和不良实践。</p>
<h3 id="毒害代码库的因素之不确定因素"><a href="#毒害代码库的因素之不确定因素" class="headerlink" title="毒害代码库的因素之不确定因素"></a>毒害代码库的因素之不确定因素</h3><p>从一个简单的例子开始。假设我们正在为一个智能家庭微控制器编写一个程序，其中一个需求是，如果是在傍晚或晚上检测到后院有运动，那么就自动打开灯。我们现在就先实现一个方法，该方法返回一天中各阶段的大致时间，用字符串表示 “Night”, “Morning”, “Afternoon” or “Evening”:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getTimeOfDay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  DateTime time = DateTime.now();</span><br><span class="line">  <span class="keyword">int</span> hour = DateUtil.hour(time, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (hour &gt;= <span class="number">0</span> &amp;&amp; hour &lt; <span class="number">6</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Night&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (hour &gt;= <span class="number">6</span> &amp;&amp; hour &lt; <span class="number">12</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Morning&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (hour &gt;= <span class="number">12</span> &amp;&amp; hour &lt; <span class="number">18</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Afternoon&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;Evening&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法获取了系统的当前时间并返回了对应的时间阶段，看起来挺正常的吧。那这段代码到底有没有问题呢？</p>
<p>我们从单元测试的角度来分析这段代码，我们就会发现，我们不可能为其写出一个基于状态的单元测试。<code>DateTime.now()</code>是一个隐式输入，在程序执行期间或者测试运行期间会产生不同的值。那么，每次对它的调用将产生不同的结果。</p>
<p>如果在不更改系统日期时间的情况下，这种非确定的行为会导致我们没有办法测试此方法。我们试着写出这个单元测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getTimeOfDayAt6AMReturnsMorning</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 安装：改变系统时间为：6 AM</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Arrange 阶段不需要动作</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Act</span></span><br><span class="line">    String timeOfDay = DayTimeService.getTimeOfDay();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Assert</span></span><br><span class="line">    Assert.assertEquals(<span class="string">&quot;Morning&quot;</span>, timeOfDay);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 拆卸: 回滚系统时间</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的测试会违背我们在前面讨论的很多规则。首先，它的编写成本很高，因为还需要比较复杂的环境的安装和拆卸。其次，它是不可靠的，可能会因为没有权限修改系统时间导致单测不通过。并且，它不能保证很快的运行。最后，这个测试并不是一个真正意义上的单元测试，因为它需要环境的安装和复原。其实这个单元测试的成本远大于收益，想必你也不会这么做吧。</p>
<p>分析下来，造成代码不可测试的问题是由低质量的 <code>getTimeOfDay()</code> 方法 API 设计引起的。在当前形式下，该方法存在以下几个问题：</p>
<ul>
<li><p><strong>和数据源紧密耦合</strong></p>
<p>如果再有一个需求是计算某个日期而非当前系统时间处在的时间阶段，那么该方法是不可重用的，紧耦合是大多数方法出现不可测试性问题的主要根源。</p>
</li>
<li><p><a href="https://en.wikipedia.org/wiki/Single_responsibility_principle"><strong>违背了单一职责原则(SRP)</strong></a></p>
<p>此方法有多种职责，它消耗信息并处理信息。单一职责原则的定义是一个类或者方法只能有一个引起其改变的原因。从这个角度来看，<code>getTimeOfDay()</code> 方法的影响因素可能是内部逻辑的改变，也可能是日期时间源的改变。</p>
</li>
<li><p><strong>对完成任务所需的信息撒谎</strong></p>
<p>对此方法来说，开发人员必须阅读源码，来了解使用了哪些隐式输入以及还要搞清楚这些隐式输入的来源，才能确定此方法是如何输出的。如果仅从方法的名称来看，是不足以理解方法的行为的。</p>
</li>
<li><p><strong>很难预测和维护</strong></p>
<p>依赖于可变的全局状态的方法，它的行为不能仅仅通过读取源代码来预测。你必须考虑全局状态的当前值，以及可能改变它的整个事件序列。在一个真正的应用程序当中，理顺这些东西是比较困难的。</p>
</li>
</ul>
<p>在我们重新审视 API 之后，让我们修复它。庆幸的是，我们打破这些紧密的耦合点是非常容易的，相比较讨论它的所有缺陷。</p>
<h4 id="修复方法：引入方法参数"><a href="#修复方法：引入方法参数" class="headerlink" title="修复方法：引入方法参数"></a>修复方法：引入方法参数</h4><p>最显而易见并且很容易的修复方法就是，为这个方法引入一个方法参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getTimeOfDay</span><span class="params">(DateTime time)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> hour = DateUtil.hour(time, <span class="keyword">true</span>);</span><br><span class="line">  <span class="keyword">if</span> (hour &gt;= <span class="number">0</span> &amp;&amp; hour &lt; <span class="number">6</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Night&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (hour &gt;= <span class="number">6</span> &amp;&amp; hour &lt; <span class="number">12</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Morning&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (hour &gt;= <span class="number">12</span> &amp;&amp; hour &lt; <span class="number">18</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Afternoon&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Evening&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在这个方法需要调用者提供一个时间参数，而不是在方法内部里面提供这个信息。从单元测试的角度来看，这是非常棒的，因为现在这个方式是确定的 —方法的返回值完全取决于方法的入参，现在基于状态的测试很简单，只需要输入时间参数，并核验返回结果就可以了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getTimeOfDayAt6AMReturnsMorning</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Arrange 阶段为空：测试静态方法，不需要初始化</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Act</span></span><br><span class="line">  String timeOfDay = DayTimeService.getTimeOfDay(<span class="keyword">new</span> DateTime(<span class="string">&quot;2015-12-31 06:00:00&quot;</span>, <span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Assert</span></span><br><span class="line">  Assert.assertEquals(<span class="string">&quot;Morning&quot;</span>, timeOfDay);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意，这简单的重构还解决了前面所提到的 API 的问题（包括紧耦合、单一职责的违背、不够清晰和难以理解的 API），它是通过清晰的分离开<em>要处理什么数据</em>和<em>如何处理</em>来做到的。</p>
<p>非常棒！这个方法是可测试的。但是对于其调用者是否友好呢？现在调用者的职责是提供日期时间给到这个方法，意味着如果我们不注意，其调用者也会和刚刚的方法一样将变得不可测试。那就让我们来看看，我们怎么处理。（如果比较难理解，别急，请继续往下看）</p>
<h4 id="修复客户端-API-：依赖注入"><a href="#修复客户端-API-：依赖注入" class="headerlink" title="修复客户端 API ：依赖注入"></a>修复客户端 API ：依赖注入</h4><p>现在我们继续研究智能家居系统，并实现了<code>getTimeOfDay</code> 方法的客户端，上述提到的智能家居微控制器代码，它对于灯光的关闭和打开，是基于一天中时间变量和运动的检测来控制的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmartHomeController</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> DateTime lastMotionTime;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> DateTime <span class="title">getLastMotionTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lastMotionTime;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actuateLights</span><span class="params">(<span class="keyword">boolean</span> motionDetected)</span> </span>&#123;</span><br><span class="line">    DateTime time = DateTime.now();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新上次检测时间</span></span><br><span class="line">		<span class="keyword">if</span> (motionDetected) &#123;</span><br><span class="line">      lastMotionTime = time;</span><br><span class="line">		&#125;</span><br><span class="line">    </span><br><span class="line">    String timeOfDay = DayTimeService.getTimeOfDay(time);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果在 evening 或者 night 检测到有运动，那么打开灯</span></span><br><span class="line">    <span class="keyword">if</span> (motionDetected &amp;&amp; (timeOfDay.equals(<span class="string">&quot;Evening&quot;</span>) || timeOfDay.equals(<span class="string">&quot;Night&quot;</span>))) &#123;</span><br><span class="line">			BackyardLightSwitcher.INSTANCE.TurnOn();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果1分钟内没有发现任何运动，或者是 morning 或 noon，请关灯</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (DateUtil.between(lastMotionTime, time, DateUnit.MINUTE) &gt; <span class="number">1</span></span><br><span class="line">             || (timeOfDay.equals(<span class="string">&quot;Morning&quot;</span>) || timeOfDay.equals(<span class="string">&quot;Noon&quot;</span>))) &#123;</span><br><span class="line">      BackyardLightSwitcher.INSTANCE.TurnOff();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>哎呦喂！我们又有隐藏输入时间的问题，与前面唯一不同的是，现在是位于更高的抽象级别上。现在我们可以引入另外一个参数，我们可以再一次在方法上增加入参<code>actuateLights(boolean motionDetected, DateTime dateTime)</code>,委托此方法的调用者提供<code>DateTime</code>参数（这个思路和前面的解决思路是一样的）。但是，与其把问题移到在更高一层调用栈上，不如采用另外一种技术，使得方法<code>actuateLights(bool motionDetected)</code>和客户端都有可测试性，这种技术就是<a href="https://en.wikipedia.org/wiki/Inversion_of_control">控制反转</a>或者称为 IOC。</p>
<p>控制反转可以通过多种方式来实现，接下来，我们来看一个特定的示例—使用构造函数进行依赖注入，看看它如何帮助我们进行构建可测试的 SmartHomeController API。</p>
<p>首先，让我们创建一个 <code>IDateTimeProvider</code> 接口，其中包括了一个获取某些日期时间的方法声明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IDateTimeProvider</span> </span>&#123;</span><br><span class="line">    <span class="function">DateTime <span class="title">getDateTime</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，使<code>SmartHomeController</code>引用<code>IDateTimeProvider</code>实现，并将获取日期时间的职责委派给它：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmartHomeController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 依赖</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> IDateTimeProvider dateTimeProvider; </span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SmartHomeController</span><span class="params">(IDateTimeProvider dateTimeProvider)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注入需要的依赖</span></span><br><span class="line">    <span class="keyword">this</span>.dateTimeProvider = dateTimeProvider;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actuateLights</span><span class="params">(<span class="keyword">boolean</span> motionDetected)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 委托职责</span></span><br><span class="line">    DateTime time = dateTimeProvider.getDateTime();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 其余的灯光控制逻辑在这儿。。。</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们看看为什么叫控制反转：其实是使用什么机制获取日期时间的<em>控制</em>权被反转了，之前是<code>SmartHomeController</code> 本身控制如何获取，而现在控制权给到了<code>SmartHomeController</code>的客户端即使用者。因此，<code>actuateLights(bool motionDetected)</code>方法的执行完全依赖于两个可以从外部轻松管理的东西：一个是<code>motionDetected</code>参数，另一个是传递到<code>SmartHomeController</code>构造函数的<code>IDateTimeProvider</code>的具体实现。</p>
<p>为什么这样做对单元测试很重要呢？因为这样我们就可以在生产环境代码和单元测试代码使用不同的<code>IDateTimeProvider</code>的实现。在生产环境中，可以注入真实的实现（比如，注入一个读取真实系统时间的实现）。在单测中，我们可以注入一个“伪”实现，返回一个适合测试特定场景的常量或者预定义的<code>DateTime</code>值。</p>
<p><code>IDateTimeProvider</code>的一个伪实现如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FakeDateTimeProvider</span> <span class="keyword">implements</span> <span class="title">IDateTimeProvider</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> DateTime returnValue;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">FakeDateTimeProvider</span><span class="params">(DateTime returnValue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.returnValue = returnValue</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> DateTime <span class="title">getDateTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> returnValue;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> DateTime <span class="title">getReturnValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> returnValue;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setReturnValue</span><span class="params">(DateTime returnValue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.returnValue = returnValue;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个类的帮助下，可以将<code>SmartHomeController</code>和不确定性因素隔离开来，并执行基于状态的单元测试。让我们验证一下，如果检测到运动，该运动的时间是否会被记录在<code>LastMotionTime</code>属性中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actuateLightsMotionDetectedSavesTimeOfMotion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Arrange</span></span><br><span class="line">  DateTime time = <span class="keyword">new</span> DateTime(<span class="string">&quot;2015-12-31 23:59:59&quot;</span>, <span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">	SmartHomeController controller = <span class="keyword">new</span> SmartHomeController(<span class="keyword">new</span> FakeDateTimeProvider(time));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Act</span></span><br><span class="line">	controller.actuateLights(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Assert</span></span><br><span class="line">  Assert.assertEquals(time, controller.getLastMotionTime());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>太棒了！像这样的单元测试在重构前是不可能的做到的。既然我们已经去除了不确定因素的影响并验证了基于状态的场景测试，那么现在你认为<code>SmartHomeController</code>是完全可测试的了吗?</p>
<h3 id="毒害代码库的因素之副作用"><a href="#毒害代码库的因素之副作用" class="headerlink" title="毒害代码库的因素之副作用"></a>毒害代码库的因素之副作用</h3><p>尽管我们解决了隐式输入的不确定因素问题，并且我们能够测试某些功能，但是代码仍然是不稳定的，至少一部分代码是这样的。</p>
<p>让我们 review 下方法<code>ActuateLights(bool motionDetected)</code>中负责打开或者关闭灯光的代码部分：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="comment">// 如果在 evening 或者 night 检测到有运动，那么打开灯</span></span><br><span class="line">	<span class="keyword">if</span> (motionDetected &amp;&amp; (timeOfDay.equals(<span class="string">&quot;Evening&quot;</span>) || timeOfDay.equals(<span class="string">&quot;Night&quot;</span>))) &#123;</span><br><span class="line">    BackyardLightSwitcher.INSTANCE.TurnOn();</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 如果1分钟内没有发现任何运动，或者是 morning 或 noon，请关灯</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (DateUtil.between(lastMotionTime, time, DateUnit.MINUTE) &gt; <span class="number">1</span></span><br><span class="line">         || (timeOfDay.equals(<span class="string">&quot;Morning&quot;</span>) || timeOfDay.equals(<span class="string">&quot;Noon&quot;</span>))) &#123;</span><br><span class="line">	BackyardLightSwitcher.INSTANCE.TurnOff();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到，<code>SmartHomeController</code>委托了开关灯的职责给到<code>BackyardLightSwitcher</code>对象，这个对象还是单例模式。但是这个设计有什么问题呢？</p>
<p>为了对方法<code>ActuateLights(bool motionDetected)</code>进行全面的单元测试，我们不仅要做基于状态的测试，还要做基于交互的测试，也就是说，我们应该确保只有在满足适当的条件时，才会调用用于打开或关闭灯光的方法。但是当前的设计，不允许我们这样做：<code>BackyardLightSwitcher</code>的<code>TurnOn()</code>和<code>TurnOff()</code>方法会触发系统中一些状态的更改，或者换句话说，会产生副作用（灯的开关）。验证开关的灯方法被调用的唯一方式是检查它们相应的副作用是否真的发生了，这样的验证会很痛苦。</p>
<p>的确，让我们假设运动传感器、后院灯和智能家居微控制器都连接到了物联网的网络中，并使用某种无线协议可以进行网络通信。在这种情况下，如果想做到上面的单元测试，我们可以尝试在单测中接受和分析网络流量，从而来核验测试结果。或者，各个硬件组件用导线连接起来，单元测试可以检查电压是否施加到对应的电路上。或者，还可以使用额外的光传感器来检查灯是否是真的打开或者关闭来进行核验。</p>
<p>正如我们所看到的，单元测试具有副作用的方法和单元测试具有不确定性的方法，这两者一样困难，甚至是不可能的。任何的尝试会导致我们之前看到的类似的问题。这个测试将变得很难实现、不可靠，还可能很慢，而且也可能不是一个真正的单元。还有，运行测试套件引起的灯光的闪烁也会让人发疯。</p>
<p>同样，所有这些可测试性问题都是由糟糕的 API 设计引起的，并不是开发人员编写单元测试的能力。无论灯的控制是怎么实现的，<code>SmartHomeController</code> API 都会遇到以下常见的问题：</p>
<ul>
<li><p><strong>和实现紧密耦合</strong></p>
<p>API 依赖于 <code>BackyardLightSwitcher</code> 硬编码的具体实现。现有方法 <code>ActuateLights(bool motionDetected)</code> 无法做到切换后院以外的任何灯光，它是不可重用的。</p>
</li>
<li><p><strong>违背了单一职责原则</strong></p>
<p>这个 API 有两个引起其改变的原因：第一，内部逻辑的改变（例如选择只在 night 开灯，而不是在 evening 打开）；第二，如果灯开关机制被另一机制取代。</p>
</li>
<li><p><strong>依赖关系上不清晰</strong></p>
<p>如果开发人员不深入研究源代码，那么他们是没有办法知道<code>SmartHomeController</code>是依赖于硬编码<code>BackyardLightSwitcher</code>。</p>
</li>
<li><p><strong>很难理解和维护</strong></p>
<p>如果条件是正确的，但是却无法打开灯光，那该怎么办呢？我们会花很多没用的时间去尝试修复<code>SmartHomeController</code>，但最终却发现问题是由<code>BackyardLightSwitcher</code>（或者，更有趣的是，灯泡烧坏了）中的一个错误引起的。</p>
</li>
</ul>
<p>解决可测试性和低质量 API 问题的方法是将紧密耦合的组件彼此分离。与前面的例子一样，使用依赖注入可以解决这类问题。只需向<code>SmartHomeController</code>添加一个<code>ILightSwitcher</code>的依赖项，将控制灯开关的责任委派给它，并传递一个假的、仅测试的<code>ILightSwitcher</code>的实现，该实现将记录是否在正确的条件下调用了适当的方法。与其再用一次依赖注入，不如让我们回顾一种有趣的分离责任的替代方式。</p>
<h4 id="修复-API：高阶函数"><a href="#修复-API：高阶函数" class="headerlink" title="修复 API：高阶函数"></a>修复 API：<a href="https://zh.wikipedia.org/wiki/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0">高阶函数</a></h4><p>这种方法是任何支持<a href="https://zh.wikipedia.org/wiki/%E5%A4%B4%E7%AD%89%E5%87%BD%E6%95%B0">头等函数</a>的面向对象语言中的一种选择。让我们利用 Java 的函数特性，让<code>actuateLights(boolean motionDetected)</code> 方法再接受两个参数：一对操作委托，指向应该调用打开或者关闭指示灯的方法。这种解决方法会将函数转化成为一个高阶函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actuateLights</span><span class="params">(<span class="keyword">boolean</span> motionDetected, Runnable turnOn, Runnable turnOff)</span> </span>&#123;</span><br><span class="line">  DateTime time = dateTimeProvider.getDateTime();</span><br><span class="line">  <span class="comment">// 更新上次检测时间</span></span><br><span class="line">  <span class="keyword">if</span> (motionDetected) &#123;</span><br><span class="line">    lastMotionTime = time;</span><br><span class="line">  &#125;</span><br><span class="line">  String timeOfDay = DayTimeService.getTimeOfDay(time);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 如果在 evening 或者 night 检测到有运动，那么打开灯</span></span><br><span class="line">  <span class="keyword">if</span> (motionDetected &amp;&amp; (timeOfDay.equals(<span class="string">&quot;Evening&quot;</span>) || timeOfDay.equals(<span class="string">&quot;Night&quot;</span>))) &#123;</span><br><span class="line">    <span class="comment">// 调用一个委托 不再紧耦合</span></span><br><span class="line">    turnOn.run();</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="comment">// 如果1分钟内没有发现任何运动，或者是 morning 或 noon，请关灯</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (DateUtil.between(lastMotionTime, time, DateUnit.MINUTE) &gt; <span class="number">1</span></span><br><span class="line">            || (timeOfDay.equals(<span class="string">&quot;Morning&quot;</span>) || timeOfDay.equals(<span class="string">&quot;Noon&quot;</span>))) &#123;</span><br><span class="line">    <span class="comment">// 调用一个委托 不再紧耦合</span></span><br><span class="line">    turnOff.run();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相比较之前见过的典型的面向对象依赖注入的方式，这是一个更具功能性的解决方案；它让我们用更少的代码和多一点的表达式来实现相同的结果。我们不再需要声明一个接口并实现来提供<code>SmartHomeController</code>所需的功能，现在我们只需要传递函数的定义。高阶函数可以视为实现控制反转的另一种方式。</p>
<p>现在我们做一个基于交互的单元测试，我们可以将易于验证的伪操作传递到控制器中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actuateLightsMotionDetectedAtNightTurnsOnTheLight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Arrange 创建一对操作实现开关灯，用一个标识表示灯的状态，并不是真正的打开或者关闭灯</span></span><br><span class="line">	AtomicBoolean turnedOn = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line">	Runnable turnOn = () -&gt; turnedOn.set(<span class="keyword">true</span>);</span><br><span class="line">	Runnable turnOff = ()-&gt; turnedOn.set(<span class="keyword">false</span>);</span><br><span class="line">  </span><br><span class="line">	DateTime time = <span class="keyword">new</span> DateTime(<span class="string">&quot;2015-12-31 23:59:59&quot;</span>, <span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">	SmartHomeController controller = <span class="keyword">new</span> SmartHomeController(<span class="keyword">new</span> FakeDateTimeProvider(time));</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Act</span></span><br><span class="line">  controller.actuateLights(<span class="keyword">true</span>, turnOn, turnOff);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Assert</span></span><br><span class="line">  Assert.assertTrue(turnedOn.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终，我们把<code>SmartHomeController</code> API 变得完全可测试，并且我们既可以对它做基于状态的测试也可以做基于交互的测试。同样，请注意，除了改进了其可测试性之外，我们也解耦了方法中的决策层代码和动作代码，以致于这个 API 变得更加干净并且可重用。</p>
<p>现在来看，为了实现完整的单测覆盖，我们可以很轻松的实现一系列类似的测试来验证所有可能出现的情况，这不是什么大不了的事情，因为这些单测很容易实现。</p>
<h2 id="杂质和可测试性"><a href="#杂质和可测试性" class="headerlink" title="杂质和可测试性"></a>杂质和可测试性</h2><p>不受控制的不确定性和副作用对代码库的破坏性是相似的。如果不小心使用，它们会导致具有欺骗性的、难以理解和维护的、紧密耦合的、不可重用的和不稳定的代码。</p>
<p>相反，既具有确定性又无副作用的方法是更易于测试、推理和重用的，以致于可以轻松构建更大的程序。在函数式编程中，这种方法称为<a href="https://en.wikipedia.org/wiki/Pure_function">纯函数</a>。我们很少在单元测试纯函数时遇到问题；我们所要做的就是传递一些参数并检查结果的正确性。真正使代码不稳定的是那些硬编码和杂质性的因素，它们不能被替换、重写或者以其他方式抽象掉。</p>
<p>杂质是有毒的：如果方法<code>Foo()</code>依赖于不确定或者有副作用的方法<code>Bar()</code>，那么<code>Foo()</code>也会变得不确定或有副作用。最终，我们可能会毒害整个代码库。如果将所有这些问题乘以一个复杂的实际应用程序的大小，那么复杂度会变得好高，我们将会被一个非常难以维护的代码库所困住，其中充满了各种坏气味、反模式、隐式依赖以及各种丑陋和令人不愉快的东西。</p>
<p><img src="http://qiniu.5ires.top/uPic/image-20200929142351748.png" alt="code"></p>
<p>然而，杂质是不可避免的。任何真实的应用一定会在某个时刻，通过和环境、数据库、配置文件、网络服务或者其他外部的系统交互，来读取和操作状态。因此，与其完全消除这些杂质，不如限制这些因素，避免让它们毒害你的代码库，并尽可能打破硬编码的依赖关系，以便能够独立地分析和进行单元测试。</p>
<h2 id="难以测试代码的常见警告标志"><a href="#难以测试代码的常见警告标志" class="headerlink" title="难以测试代码的常见警告标志"></a>难以测试代码的常见警告标志</h2><p>现在看来写单测还是困难吗？其实我们也看到了，问题不是你的测试套件，而是你的代码。</p>
<p>最后，让我们回顾一些常见的警告标志，这些标志表明我们的代码可能很难测试。</p>
<h3 id="静态属性和字段"><a href="#静态属性和字段" class="headerlink" title="静态属性和字段"></a>静态属性和字段</h3><p>静态属性和字段，或者简单的说，全局状态，它们通过隐藏了方法所需要的信息，引入了非确定性，或者推动了副作用的广泛使用，可能会复杂化代码的理解和可测试性。读取或者修改可变全局状态的函数本质上是不纯洁的。</p>
<p>例如，很难对以下代码进行推理，这些代码依赖于全局可访问的属性：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!SmartHomeSettings.CostSavingEnabled) &#123;</span><br><span class="line">  _swimmingPoolController.HeatWater(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果<code> HeatWater()</code>方法在某个场景，我们确定应该被调用却没有被调用，这时我们该怎么办？因为在应用中任何部分都有可能改变<code>CostSavingEnabled</code>的值，所以我们为了弄清楚是哪里出错了，必须找到并分析所有可以改变此值的地方。此外，正如我们已经看到的，为了测试目的，我们不可能设置这些静态属性（例如<code>DateTime.Now</code>, or <code>Environment.MachineName</code>；它们虽然是只读的，但仍然不确定）。</p>
<p>相反地，不可变的和确定性的全局状态是完全 OK 的。事实上，它有一个更熟悉的名字 - 常量。常量值，例如<code>Math.PI</code>不会引入任何非确定性，并且其值是不能被改变的，因此不允许任何副作用。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 仍然是一个纯洁的函数</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Circumference</span>(<span class="params"><span class="keyword">double</span> radius</span>)</span> &#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span> * Math.PI * radius; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h3><p>从本质上讲，单例模式只是全局状态的另一种形式。单例提升了 API 的模糊性，这些 API 掩盖了真正的依赖关系，并在组件间引入了不必要的紧密耦合。此外，它们还违反了单一责任原则，因为除了它负责的主要职责之外，它们还控制了自己的初始化和生命周期。</p>
<p>单例程序很轻易地使单元测试依赖代码顺序，因为它们在整个应用程序或单元测试套件的生命周期中都携带了状态。请看以下示例：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function">User <span class="title">GetUser</span>(<span class="params"><span class="keyword">int</span> userId</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    User user;</span><br><span class="line">    <span class="keyword">if</span> (UserCache.Instance.ContainsKey(userId))</span><br><span class="line">    &#123;</span><br><span class="line">        user = UserCache.Instance[userId];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        user = _userService.LoadUser(userId);</span><br><span class="line">        UserCache.Instance[userId] = user;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，如果首先测试缓存命中的场景，那么会事先向缓存中添加一个新用户，因此缓存未命中场景的后续测试可能会失败，因为它假定缓存为空。为了克服这个问题，我们必须在每次单元测试运行之后编写额外的<code>teardown</code>代码来清理 UserCache。</p>
<p>在大多数情况下，使用 Singleton 是一种不好的做法，可以（也应该）避免；但是，区分作为设计模式的<code>Singleton</code> 和对象的单个实例是很重要的。在后一种情况下，创建和维护单个实例的责任在于应用程序本身。通常，这是一个工厂或依赖注入容器，它在应用程序的<code>top</code>附近（即靠近应用程序入口点）创建一个实例，然后将其传递给每个需要它的对象。从可测试性和 API 质量的角度来看，这种方法是绝对正确的。</p>
<h3 id="new的操作"><a href="#new的操作" class="headerlink" title="new的操作"></a><code>new</code>的操作</h3><p>为了完成某些工作而创建一个对象的实例会带来和 Singleton 反模式相同的问题：造成 API 的不清晰，其中具有隐藏的依赖关系、紧密的耦合度和较差的可测试性。</p>
<p>例如，为了测试当返回404状态代码时，以下循环是否停止，开发人员应设置一个测试web服务器：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> client = <span class="keyword">new</span> HttpClient())</span><br><span class="line">&#123;</span><br><span class="line">    HttpResponseMessage response;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        response = <span class="keyword">await</span> client.GetAsync(uri);</span><br><span class="line">        <span class="comment">// Process the response and update the uri...</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (response.StatusCode != HttpStatusCode.NotFound);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而，<code>new</code>有时候是完全无害的：例如，创建一个简单的实体类对象完全 OK：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">&quot;John&quot;</span>, <span class="string">&quot;Doe&quot;</span>, <span class="keyword">new</span> DateTime(<span class="number">1970</span>, <span class="number">12</span>, <span class="number">31</span>));</span><br></pre></td></tr></table></figure>

<p>其实创建一个不产生任何副作用的小的临时的对象也是可以的，除非需要修改它们自己的状态，并且基于该状态返回结果。在下面的示例中，我们不关心是否调用了<code>Stack</code>方法—我们只检查最终结果是否正确：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">string</span> <span class="title">ReverseString</span>(<span class="params"><span class="keyword">string</span> input</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// No need to do interaction-based testing and check that Stack methods were called or not;</span></span><br><span class="line">    <span class="comment">// The unit test just needs to ensure that the return value is correct (state-based testing).</span></span><br><span class="line">    <span class="keyword">var</span> stack = <span class="keyword">new</span> Stack&lt;<span class="keyword">char</span>&gt;();</span><br><span class="line">    <span class="keyword">foreach</span>(<span class="keyword">var</span> s <span class="keyword">in</span> input)</span><br><span class="line">    &#123;</span><br><span class="line">        stack.Push(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">string</span> result = <span class="keyword">string</span>.Empty;</span><br><span class="line">    <span class="keyword">while</span>(stack.Count != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        result += stack.Pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>静态方法是不确定性或者副作用行为的另一个潜在来源。它们很容易引入紧耦合，使我们的代码不稳定。</p>
<p>例如，要验证以下方法的行为，单元测试必须操作环境变量并读取控制台输出流，以确保打印了适当的数据：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CheckPathEnvironmentVariable</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Environment.GetEnvironmentVariable(<span class="string">&quot;PATH&quot;</span>) != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;PATH environment variable exists.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">       Console.WriteLine(<span class="string">&quot;PATH environment variable is not defined.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，干净的静态函数是被允许的：因为它们的任何组合仍然是干净的函数。例如：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Hypotenuse</span>(<span class="params"><span class="keyword">double</span> side1, <span class="keyword">double</span> side2</span>)</span> &#123; </span><br><span class="line">  <span class="keyword">return</span> Math.Sqrt(Math.Pow(side1, <span class="number">2</span>) + Math.Pow(side2, <span class="number">2</span>)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="单元测试的好处"><a href="#单元测试的好处" class="headerlink" title="单元测试的好处"></a>单元测试的好处</h2><p>显然，编写可测试代码需要一定的纪律性、专注力和额外的努力。我们尽管在软件开发中会存在复杂的心理活动，但是也应该时刻小心，避免鲁莽地从头就开始盲目的堆砌代码。</p>
<p>如果我们保证了软件的开发质量，那么我们最终会得到干净的、易于维护的、低耦合的和可重用的 API， 当开发人员理解这些 API 的时候，以致于不会让他们头疼。毕竟，可测试性代码的最终优势不止在于其本身的可测试，更给代码带来了易理解、易维护和易扩展的优点。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>原文作者讨论了 API 的设计对单元测试的影响，以及该怎么去做好 API 设计和单元测试。这篇文章作者讲的很详细，让我也大致理解了之前听到过的“面向测试编程”的说法。在时间允许的情况下，我们就把单元测试编写起来吧，毕竟好处大大的，同时，还能修整你的代码库。</p>
<p><em>英文原文链接：<a href="https://www.toptal.com/qa/how-to-write-testable-code-and-why-it-matters">https://www.toptal.com/qa/how-to-write-testable-code-and-why-it-matters</a></em></p>
]]></content>
  </entry>
</search>
